(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

if (document.readyState === 'complete' ||
    document.readyState === 'interactive') {
    window.setTimeout(_boot, 0);
} else {
    document.addEventListener('DOMContentLoaded', _boot, false);
    window.addEventListener('load', _boot, false);
}

function _boot() {
    if (!document.body) {
        window.setTimeout(_boot, 20);
    } else {
        document.removeEventListener('DOMContentLoaded', _boot);
        window.removeEventListener('load', _boot);

        window.log = console.log.bind(console);

        var extensions = require('./utils/extensions.js');
        var fishing = require('./fishing.js');
        fishing();
    }
};

},{"./fishing.js":41,"./utils/extensions.js":62}],2:[function(require,module,exports){
module.exports = require('./src/PathFinding');

},{"./src/PathFinding":5}],3:[function(require,module,exports){
module.exports = require('./lib/heap');

},{"./lib/heap":4}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
    module.exports = Heap;
  } else {
    window.Heap = Heap;
  }

}).call(this);

},{}],5:[function(require,module,exports){
module.exports = {
    'Heap'                      : require('heap'),
    'Node'                      : require('./core/Node'),
    'Grid'                      : require('./core/Grid'),
    'Util'                      : require('./core/Util'),
	'DiagonalMovement'          : require('./core/DiagonalMovement'),
    'Heuristic'                 : require('./core/Heuristic'),
    'AStarFinder'               : require('./finders/AStarFinder'),
    'BestFirstFinder'           : require('./finders/BestFirstFinder'),
    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),
    'DijkstraFinder'            : require('./finders/DijkstraFinder'),
    'BiAStarFinder'             : require('./finders/BiAStarFinder'),
    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),
    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),
    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),
    'IDAStarFinder'             : require('./finders/IDAStarFinder'),
    'JumpPointFinder'           : require('./finders/JumpPointFinder'),
};

},{"./core/DiagonalMovement":6,"./core/Grid":7,"./core/Heuristic":8,"./core/Node":9,"./core/Util":10,"./finders/AStarFinder":11,"./finders/BestFirstFinder":12,"./finders/BiAStarFinder":13,"./finders/BiBestFirstFinder":14,"./finders/BiBreadthFirstFinder":15,"./finders/BiDijkstraFinder":16,"./finders/BreadthFirstFinder":17,"./finders/DijkstraFinder":18,"./finders/IDAStarFinder":19,"./finders/JumpPointFinder":24,"heap":3}],6:[function(require,module,exports){
var DiagonalMovement = {
    Always: 1,
    Never: 2,
    IfAtMostOneObstacle: 3,
    OnlyWhenNoObstacles: 4
};

module.exports = DiagonalMovement;
},{}],7:[function(require,module,exports){
var Node = require('./Node');
var DiagonalMovement = require('./DiagonalMovement');

/**
 * The Grid class, which serves as the encapsulation of the layout of the nodes.
 * @constructor
 * @param {number} width Number of columns of the grid.
 * @param {number} height Number of rows of the grid.
 * @param {Array.<Array.<(number|boolean)>>} [matrix] - A 0-1 matrix
 *     representing the walkable status of the nodes(0 or false for walkable).
 *     If the matrix is not supplied, all the nodes will be walkable.  */
function Grid(width, height, matrix) {
    /**
     * The number of columns of the grid.
     * @type number
     */
    this.width = width;
    /**
     * The number of rows of the grid.
     * @type number
     */
    this.height = height;

    /**
     * A 2D array of nodes.
     */
    this.nodes = this._buildNodes(width, height, matrix);
}

/**
 * Build and return the nodes.
 * @private
 * @param {number} width
 * @param {number} height
 * @param {Array.<Array.<number|boolean>>} [matrix] - A 0-1 matrix representing
 *     the walkable status of the nodes.
 * @see Grid
 */
Grid.prototype._buildNodes = function(width, height, matrix) {
    var i, j,
        nodes = new Array(height),
        row;

    for (i = 0; i < height; ++i) {
        nodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            nodes[i][j] = new Node(j, i);
        }
    }


    if (matrix === undefined) {
        return nodes;
    }

    if (matrix.length !== height || matrix[0].length !== width) {
        throw new Error('Matrix size does not fit');
    }

    for (i = 0; i < height; ++i) {
        for (j = 0; j < width; ++j) {
            if (matrix[i][j]) {
                // 0, false, null will be walkable
                // while others will be un-walkable
                nodes[i][j].walkable = false;
            }
        }
    }

    return nodes;
};


Grid.prototype.getNodeAt = function(x, y) {
    return this.nodes[y][x];
};


/**
 * Determine whether the node at the given position is walkable.
 * (Also returns false if the position is outside the grid.)
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @return {boolean} - The walkability of the node.
 */
Grid.prototype.isWalkableAt = function(x, y) {
    return this.isInside(x, y) && this.nodes[y][x].walkable;
};


/**
 * Determine whether the position is inside the grid.
 * XXX: `grid.isInside(x, y)` is wierd to read.
 * It should be `(x, y) is inside grid`, but I failed to find a better
 * name for this method.
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
Grid.prototype.isInside = function(x, y) {
    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
};


/**
 * Set whether the node on the given position is walkable.
 * NOTE: throws exception if the coordinate is not inside the grid.
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @param {boolean} walkable - Whether the position is walkable.
 */
Grid.prototype.setWalkableAt = function(x, y, walkable) {
    this.nodes[y][x].walkable = walkable;
};


/**
 * Get the neighbors of the given node.
 *
 *     offsets      diagonalOffsets:
 *  +---+---+---+    +---+---+---+
 *  |   | 0 |   |    | 0 |   | 1 |
 *  +---+---+---+    +---+---+---+
 *  | 3 |   | 1 |    |   |   |   |
 *  +---+---+---+    +---+---+---+
 *  |   | 2 |   |    | 3 |   | 2 |
 *  +---+---+---+    +---+---+---+
 *
 *  When allowDiagonal is true, if offsets[i] is valid, then
 *  diagonalOffsets[i] and
 *  diagonalOffsets[(i + 1) % 4] is valid.
 * @param {Node} node
 * @param {DiagonalMovement} diagonalMovement
 */
Grid.prototype.getNeighbors = function(node, diagonalMovement) {
    var x = node.x,
        y = node.y,
        neighbors = [],
        s0 = false, d0 = false,
        s1 = false, d1 = false,
        s2 = false, d2 = false,
        s3 = false, d3 = false,
        nodes = this.nodes;

    // ↑
    if (this.isWalkableAt(x, y - 1)) {
        neighbors.push(nodes[y - 1][x]);
        s0 = true;
    }
    // →
    if (this.isWalkableAt(x + 1, y)) {
        neighbors.push(nodes[y][x + 1]);
        s1 = true;
    }
    // ↓
    if (this.isWalkableAt(x, y + 1)) {
        neighbors.push(nodes[y + 1][x]);
        s2 = true;
    }
    // ←
    if (this.isWalkableAt(x - 1, y)) {
        neighbors.push(nodes[y][x - 1]);
        s3 = true;
    }

    if (diagonalMovement === DiagonalMovement.Never) {
        return neighbors;
    }

    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        d0 = s3 && s0;
        d1 = s0 && s1;
        d2 = s1 && s2;
        d3 = s2 && s3;
    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {
        d0 = s3 || s0;
        d1 = s0 || s1;
        d2 = s1 || s2;
        d3 = s2 || s3;
    } else if (diagonalMovement === DiagonalMovement.Always) {
        d0 = true;
        d1 = true;
        d2 = true;
        d3 = true;
    } else {
        throw new Error('Incorrect value of diagonalMovement');
    }

    // ↖
    if (d0 && this.isWalkableAt(x - 1, y - 1)) {
        neighbors.push(nodes[y - 1][x - 1]);
    }
    // ↗
    if (d1 && this.isWalkableAt(x + 1, y - 1)) {
        neighbors.push(nodes[y - 1][x + 1]);
    }
    // ↘
    if (d2 && this.isWalkableAt(x + 1, y + 1)) {
        neighbors.push(nodes[y + 1][x + 1]);
    }
    // ↙
    if (d3 && this.isWalkableAt(x - 1, y + 1)) {
        neighbors.push(nodes[y + 1][x - 1]);
    }

    return neighbors;
};


/**
 * Get a clone of this grid.
 * @return {Grid} Cloned grid.
 */
Grid.prototype.clone = function() {
    var i, j,

        width = this.width,
        height = this.height,
        thisNodes = this.nodes,

        newGrid = new Grid(width, height),
        newNodes = new Array(height),
        row;

    for (i = 0; i < height; ++i) {
        newNodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);
        }
    }

    newGrid.nodes = newNodes;

    return newGrid;
};

module.exports = Grid;

},{"./DiagonalMovement":6,"./Node":9}],8:[function(require,module,exports){
/**
 * @namespace PF.Heuristic
 * @description A collection of heuristic functions.
 */
module.exports = {

  /**
   * Manhattan distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} dx + dy
   */
  manhattan: function(dx, dy) {
      return dx + dy;
  },

  /**
   * Euclidean distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy)
   */
  euclidean: function(dx, dy) {
      return Math.sqrt(dx * dx + dy * dy);
  },

  /**
   * Octile distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy) for grids
   */
  octile: function(dx, dy) {
      var F = Math.SQRT2 - 1;
      return (dx < dy) ? F * dx + dy : F * dy + dx;
  },

  /**
   * Chebyshev distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} max(dx, dy)
   */
  chebyshev: function(dx, dy) {
      return Math.max(dx, dy);
  }

};

},{}],9:[function(require,module,exports){
/**
 * A node in grid. 
 * This class holds some basic information about a node and custom 
 * attributes may be added, depending on the algorithms' needs.
 * @constructor
 * @param {number} x - The x coordinate of the node on the grid.
 * @param {number} y - The y coordinate of the node on the grid.
 * @param {boolean} [walkable] - Whether this node is walkable.
 */
function Node(x, y, walkable) {
    /**
     * The x coordinate of the node on the grid.
     * @type number
     */
    this.x = x;
    /**
     * The y coordinate of the node on the grid.
     * @type number
     */
    this.y = y;
    /**
     * Whether this node can be walked through.
     * @type boolean
     */
    this.walkable = (walkable === undefined ? true : walkable);
}

module.exports = Node;

},{}],10:[function(require,module,exports){
/**
 * Backtrace according to the parent records and return the path.
 * (including both start and end nodes)
 * @param {Node} node End node
 * @return {Array.<Array.<number>>} the path
 */
function backtrace(node) {
    var path = [[node.x, node.y]];
    while (node.parent) {
        node = node.parent;
        path.push([node.x, node.y]);
    }
    return path.reverse();
}
exports.backtrace = backtrace;

/**
 * Backtrace from start and end node, and return the path.
 * (including both start and end nodes)
 * @param {Node}
 * @param {Node}
 */
function biBacktrace(nodeA, nodeB) {
    var pathA = backtrace(nodeA),
        pathB = backtrace(nodeB);
    return pathA.concat(pathB.reverse());
}
exports.biBacktrace = biBacktrace;

/**
 * Compute the length of the path.
 * @param {Array.<Array.<number>>} path The path
 * @return {number} The length of the path
 */
function pathLength(path) {
    var i, sum = 0, a, b, dx, dy;
    for (i = 1; i < path.length; ++i) {
        a = path[i - 1];
        b = path[i];
        dx = a[0] - b[0];
        dy = a[1] - b[1];
        sum += Math.sqrt(dx * dx + dy * dy);
    }
    return sum;
}
exports.pathLength = pathLength;


/**
 * Given the start and end coordinates, return all the coordinates lying
 * on the line formed by these coordinates, based on Bresenham's algorithm.
 * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification
 * @param {number} x0 Start x coordinate
 * @param {number} y0 Start y coordinate
 * @param {number} x1 End x coordinate
 * @param {number} y1 End y coordinate
 * @return {Array.<Array.<number>>} The coordinates on the line
 */
function interpolate(x0, y0, x1, y1) {
    var abs = Math.abs,
        line = [],
        sx, sy, dx, dy, err, e2;

    dx = abs(x1 - x0);
    dy = abs(y1 - y0);

    sx = (x0 < x1) ? 1 : -1;
    sy = (y0 < y1) ? 1 : -1;

    err = dx - dy;

    while (true) {
        line.push([x0, y0]);

        if (x0 === x1 && y0 === y1) {
            break;
        }
        
        e2 = 2 * err;
        if (e2 > -dy) {
            err = err - dy;
            x0 = x0 + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
    }

    return line;
}
exports.interpolate = interpolate;


/**
 * Given a compressed path, return a new path that has all the segments
 * in it interpolated.
 * @param {Array.<Array.<number>>} path The path
 * @return {Array.<Array.<number>>} expanded path
 */
function expandPath(path) {
    var expanded = [],
        len = path.length,
        coord0, coord1,
        interpolated,
        interpolatedLen,
        i, j;

    if (len < 2) {
        return expanded;
    }

    for (i = 0; i < len - 1; ++i) {
        coord0 = path[i];
        coord1 = path[i + 1];

        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
        interpolatedLen = interpolated.length;
        for (j = 0; j < interpolatedLen - 1; ++j) {
            expanded.push(interpolated[j]);
        }
    }
    expanded.push(path[len - 1]);

    return expanded;
}
exports.expandPath = expandPath;


/**
 * Smoothen the give path.
 * The original path will not be modified; a new path will be returned.
 * @param {PF.Grid} grid
 * @param {Array.<Array.<number>>} path The path
 */
function smoothenPath(grid, path) {
    var len = path.length,
        x0 = path[0][0],        // path start x
        y0 = path[0][1],        // path start y
        x1 = path[len - 1][0],  // path end x
        y1 = path[len - 1][1],  // path end y
        sx, sy,                 // current start coordinate
        ex, ey,                 // current end coordinate
        newPath,
        i, j, coord, line, testCoord, blocked;

    sx = x0;
    sy = y0;
    newPath = [[sx, sy]];

    for (i = 2; i < len; ++i) {
        coord = path[i];
        ex = coord[0];
        ey = coord[1];
        line = interpolate(sx, sy, ex, ey);

        blocked = false;
        for (j = 1; j < line.length; ++j) {
            testCoord = line[j];

            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                blocked = true;
                break;
            }
        }
        if (blocked) {
            lastValidCoord = path[i - 1];
            newPath.push(lastValidCoord);
            sx = lastValidCoord[0];
            sy = lastValidCoord[1];
        }
    }
    newPath.push([x1, y1]);

    return newPath;
}
exports.smoothenPath = smoothenPath;


/**
 * Compress a path, remove redundant nodes without altering the shape
 * The original path is not modified
 * @param {Array.<Array.<number>>} path The path
 * @return {Array.<Array.<number>>} The compressed path
 */
function compressPath(path) {

    // nothing to compress
    if(path.length < 3) {
        return path;
    }

    var compressed = [],
        sx = path[0][0], // start x
        sy = path[0][1], // start y
        px = path[1][0], // second point x
        py = path[1][1], // second point y
        dx = px - sx, // direction between the two points
        dy = py - sy, // direction between the two points
        lx, ly,
        ldx, ldy,
        sq, i;

    // normalize the direction
    sq = Math.sqrt(dx*dx + dy*dy);
    dx /= sq;
    dy /= sq;

    // start the new path
    compressed.push([sx,sy]);

    for(i = 2; i < path.length; i++) {

        // store the last point
        lx = px;
        ly = py;

        // store the last direction
        ldx = dx;
        ldy = dy;

        // next point
        px = path[i][0];
        py = path[i][1];

        // next direction
        dx = px - lx;
        dy = py - ly;

        // normalize
        sq = Math.sqrt(dx*dx + dy*dy);
        dx /= sq;
        dy /= sq;

        // if the direction has changed, store the point
        if ( dx !== ldx || dy !== ldy ) {
            compressed.push([lx,ly]);
        }
    }

    // store the last point
    compressed.push([px,py]);

    return compressed;
}
exports.compressPath = compressPath;

},{}],11:[function(require,module,exports){
var Heap       = require('heap');
var Util       = require('../core/Util');
var Heuristic  = require('../core/Heuristic');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * A* path-finder.
 * based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths, 
 *     in order to speed up the search.
 */
function AStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    //When diagonal movement is allowed the manhattan heuristic is not admissible
    //It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path.
 * @return {Array.<[number, number]>} The path, including both start and
 *     end positions.
 */
AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng;

    // set the `g` and `f` value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        node.closed = true;

        // if reached the end position, construct the path and return it
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    openList.push(neighbor);
                    neighbor.opened = true;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    openList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
};

module.exports = AStarFinder;

},{"../core/DiagonalMovement":6,"../core/Heuristic":8,"../core/Util":10,"heap":3}],12:[function(require,module,exports){
var AStarFinder = require('./AStarFinder');

/**
 * Best-First-Search path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function BestFirstFinder(opt) {
    AStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}

BestFirstFinder.prototype = new AStarFinder();
BestFirstFinder.prototype.constructor = BestFirstFinder;

module.exports = BestFirstFinder;

},{"./AStarFinder":11}],13:[function(require,module,exports){
var Heap       = require('heap');
var Util       = require('../core/Util');
var Heuristic  = require('../core/Heuristic');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * A* path-finder.
 * based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths, 
 *     in order to speed up the search.
 */
function BiAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    //When diagonal movement is allowed the manhattan heuristic is not admissible
    //It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path.
 * @return {Array.<[number, number]>} The path, including both start and
 *     end positions.
 */
BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var cmp = function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        },
        startOpenList = new Heap(cmp),
        endOpenList = new Heap(cmp),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng,
        BY_START = 1, BY_END = 2;

    // set the `g` and `f` value of the start node to be 0
    // and push it into the start open list
    startNode.g = 0;
    startNode.f = 0;
    startOpenList.push(startNode);
    startNode.opened = BY_START;

    // set the `g` and `f` value of the end node to be 0
    // and push it into the open open list
    endNode.g = 0;
    endNode.f = 0;
    endOpenList.push(endNode);
    endNode.opened = BY_END;

    // while both the open lists are not empty
    while (!startOpenList.empty() && !endOpenList.empty()) {

        // pop the position of start node which has the minimum `f` value.
        node = startOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_END) {
                return Util.biBacktrace(node, neighbor);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    startOpenList.push(neighbor);
                    neighbor.opened = BY_START;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    startOpenList.updateItem(neighbor);
                }
            }
        } // end for each neighbor


        // pop the position of end node which has the minimum `f` value.
        node = endOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_START) {
                return Util.biBacktrace(neighbor, node);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h || weight * heuristic(abs(x - startX), abs(y - startY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    endOpenList.push(neighbor);
                    neighbor.opened = BY_END;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    endOpenList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
};

module.exports = BiAStarFinder;

},{"../core/DiagonalMovement":6,"../core/Heuristic":8,"../core/Util":10,"heap":3}],14:[function(require,module,exports){
var BiAStarFinder = require('./BiAStarFinder');

/**
 * Bi-direcitional Best-First-Search path-finder.
 * @constructor
 * @extends BiAStarFinder
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function BiBestFirstFinder(opt) {
    BiAStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}

BiBestFirstFinder.prototype = new BiAStarFinder();
BiBestFirstFinder.prototype.constructor = BiBestFirstFinder;

module.exports = BiBestFirstFinder;

},{"./BiAStarFinder":13}],15:[function(require,module,exports){
var Util = require('../core/Util');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * Bi-directional Breadth-First-Search path finder.
 * @constructor
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BiBreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}


/**
 * Find and return the the path.
 * @return {Array.<[number, number]>} The path, including both start and
 *     end positions.
 */
BiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        startOpenList = [], endOpenList = [],
        neighbors, neighbor, node,
        diagonalMovement = this.diagonalMovement,
        BY_START = 0, BY_END = 1,
        i, l;

    // push the start and end nodes into the queues
    startOpenList.push(startNode);
    startNode.opened = true;
    startNode.by = BY_START;

    endOpenList.push(endNode);
    endNode.opened = true;
    endNode.by = BY_END;

    // while both the queues are not empty
    while (startOpenList.length && endOpenList.length) {

        // expand start open list

        node = startOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                // if this node has been inspected by the reversed search,
                // then a path is found.
                if (neighbor.by === BY_END) {
                    return Util.biBacktrace(node, neighbor);
                }
                continue;
            }
            startOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_START;
        }

        // expand end open list

        node = endOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                if (neighbor.by === BY_START) {
                    return Util.biBacktrace(neighbor, node);
                }
                continue;
            }
            endOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_END;
        }
    }

    // fail to find the path
    return [];
};

module.exports = BiBreadthFirstFinder;

},{"../core/DiagonalMovement":6,"../core/Util":10}],16:[function(require,module,exports){
var BiAStarFinder = require('./BiAStarFinder');

/**
 * Bi-directional Dijkstra path-finder.
 * @constructor
 * @extends BiAStarFinder
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BiDijkstraFinder(opt) {
    BiAStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}

BiDijkstraFinder.prototype = new BiAStarFinder();
BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;

module.exports = BiDijkstraFinder;

},{"./BiAStarFinder":13}],17:[function(require,module,exports){
var Util = require('../core/Util');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * Breadth-First-Search path finder.
 * @constructor
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}

/**
 * Find and return the the path.
 * @return {Array.<[number, number]>} The path, including both start and
 *     end positions.
 */
BreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = [],
        diagonalMovement = this.diagonalMovement,
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        neighbors, neighbor, node, i, l;

    // push the start pos into the queue
    openList.push(startNode);
    startNode.opened = true;

    // while the queue is not empty
    while (openList.length) {
        // take the front node from the queue
        node = openList.shift();
        node.closed = true;

        // reached the end position
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            // skip this neighbor if it has been inspected before
            if (neighbor.closed || neighbor.opened) {
                continue;
            }

            openList.push(neighbor);
            neighbor.opened = true;
            neighbor.parent = node;
        }
    }
    
    // fail to find the path
    return [];
};

module.exports = BreadthFirstFinder;

},{"../core/DiagonalMovement":6,"../core/Util":10}],18:[function(require,module,exports){
var AStarFinder = require('./AStarFinder');

/**
 * Dijkstra path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function DijkstraFinder(opt) {
    AStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}

DijkstraFinder.prototype = new AStarFinder();
DijkstraFinder.prototype.constructor = DijkstraFinder;

module.exports = DijkstraFinder;

},{"./AStarFinder":11}],19:[function(require,module,exports){
var Util       = require('../core/Util');
var Heuristic  = require('../core/Heuristic');
var Node       = require('../core/Node');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * Iterative Deeping A Star (IDA*) path-finder.
 *
 * Recursion based on:
 *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html
 *
 * Path retracing based on:
 *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh
 *  "A Parallel Implementation of Iterative-Deeping-A*", January 1987.
 *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf
 *
 * @author Gerard Meier (www.gerardmeier.com)
 *
 * @constructor
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths,
 *     in order to speed up the search.
 * @param {object} opt.trackRecursion Whether to track recursion for statistical purposes.
 * @param {object} opt.timeLimit Maximum execution time. Use <= 0 for infinite.
 */

function IDAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.trackRecursion = opt.trackRecursion || false;
    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    //When diagonal movement is allowed the manhattan heuristic is not admissible
    //It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path. When an empty array is returned, either
 * no path is possible, or the maximum execution time is reached.
 *
 * @return {Array.<[number, number]>} The path, including both start and
 *     end positions.
 */
IDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    // Used for statistics:
    var nodesVisited = 0;

    // Execution time limitation:
    var startTime = new Date().getTime();

    // Heuristic helper:
    var h = function(a, b) {
        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
    }.bind(this);

    // Step cost from a to b:
    var cost = function(a, b) {
        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
    };

    /**
     * IDA* search implementation.
     *
     * @param {Node} The node currently expanding from.
     * @param {number} Cost to reach the given node.
     * @param {number} Maximum search depth (cut-off value).
     * @param {{Array.<[number, number]>}} The found route.
     * @param {number} Recursion depth.
     *
     * @return {Object} either a number with the new optimal cut-off depth,
     * or a valid node instance, in which case a path was found.
     */
    var search = function(node, g, cutoff, route, depth) {
        nodesVisited++;

        // Enforce timelimit:
        if(this.timeLimit > 0 && new Date().getTime() - startTime > this.timeLimit * 1000) {
            // Enforced as "path-not-found".
            return Infinity;
        }

        var f = g + h(node, end) * this.weight;

        // We've searched too deep for this iteration.
        if(f > cutoff) {
            return f;
        }

        if(node == end) {
            route[depth] = [node.x, node.y];
            return node;
        }

        var min, t, k, neighbour;

        var neighbours = grid.getNeighbors(node, this.diagonalMovement);

        // Sort the neighbours, gives nicer paths. But, this deviates
        // from the original algorithm - so I left it out.
        //neighbours.sort(function(a, b){
        //    return h(a, end) - h(b, end);
        //});

        
        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment
        for(k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment
            if(this.trackRecursion) {
                // Retain a copy for visualisation. Due to recursion, this
                // node may be part of other paths too.
                neighbour.retainCount = neighbour.retainCount + 1 || 1;

                if(neighbour.tested !== true) {
                    neighbour.tested = true;
                }
            }

            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);

            if(t instanceof Node) {
                route[depth] = [node.x, node.y];

                // For a typical A* linked list, this would work:
                // neighbour.parent = node;
                return t;
            }

            // Decrement count, then determine whether it's actually closed.
            if(this.trackRecursion && (--neighbour.retainCount) === 0) {
                neighbour.tested = false;
            }

            if(t < min) {
                min = t;
            }
        }

        return min;

    }.bind(this);

    // Node instance lookups:
    var start = grid.getNodeAt(startX, startY);
    var end   = grid.getNodeAt(endX, endY);

    // Initial search depth, given the typical heuristic contraints,
    // there should be no cheaper route possible.
    var cutOff = h(start, end);

    var j, route, t;

    // With an overflow protection.
    for(j = 0; true; ++j) {
        //console.log("Iteration: " + j + ", search cut-off value: " + cutOff + ", nodes visited thus far: " + nodesVisited + ".");

        route = [];

        // Search till cut-off depth:
        t = search(start, 0, cutOff, route, 0);

        // Route not possible, or not found in time limit.
        if(t === Infinity) {
            return [];
        }

        // If t is a node, it's also the end node. Route is now
        // populated with a valid path to the end node.
        if(t instanceof Node) {
            //console.log("Finished at iteration: " + j + ", search cut-off value: " + cutOff + ", nodes visited: " + nodesVisited + ".");
            return route;
        }

        // Try again, this time with a deeper cut-off. The t score
        // is the closest we got to the end node.
        cutOff = t;
    }

    // This _should_ never to be reached.
    return [];
};

module.exports = IDAStarFinder;

},{"../core/DiagonalMovement":6,"../core/Heuristic":8,"../core/Node":9,"../core/Util":10}],20:[function(require,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = require('./JumpPointFinderBase');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which always moves
 * diagonally irrespective of the number of obstacles.
 */
function JPFAlwaysMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();
JPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array.<[number, number]>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    return this._jump(x + dx, y + dy, x, y);
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array.<[number, number]>} The neighbors found.
 */
JPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x + dx, y + dy)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                }
                if (!grid.isWalkableAt(x + 1, y)) {
                    neighbors.push([x + 1, y + dy]);
                }
                if (!grid.isWalkableAt(x - 1, y)) {
                    neighbors.push([x - 1, y + dy]);
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                }
                if (!grid.isWalkableAt(x, y + 1)) {
                    neighbors.push([x + dx, y + 1]);
                }
                if (!grid.isWalkableAt(x, y - 1)) {
                    neighbors.push([x + dx, y - 1]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFAlwaysMoveDiagonally;

},{"../core/DiagonalMovement":6,"./JumpPointFinderBase":25}],21:[function(require,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = require('./JumpPointFinderBase');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there is at most one obstacle.
 */
function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();
JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array.<[number, number]>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array.<[number, number]>} The neighbors found.
 */
JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                    if (!grid.isWalkableAt(x + 1, y)) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - 1, y)) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                    if (!grid.isWalkableAt(x, y + 1)) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (!grid.isWalkableAt(x, y - 1)) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFMoveDiagonallyIfAtMostOneObstacle;

},{"../core/DiagonalMovement":6,"./JumpPointFinderBase":25}],22:[function(require,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = require('./JumpPointFinderBase');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there are no obstacles.
 */
function JPFMoveDiagonallyIfNoObstacles(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();
JPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array.<[number, number]>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            // return [x, y];
        // }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if (dx !== 0) {
            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                return [x, y];
            }
        }
        else if (dy !== 0) {
            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                return [x, y];
            }
            // When moving vertically, must check for horizontal jump points
            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                // return [x, y];
            // }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array.<[number, number]>} The neighbors found.
 */
JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
        }
        // search horizontally/vertically
        else {
            var isNextWalkable;
            if (dx !== 0) {
                isNextWalkable = grid.isWalkableAt(x + dx, y);
                var isTopWalkable = grid.isWalkableAt(x, y + 1);
                var isBottomWalkable = grid.isWalkableAt(x, y - 1);

                if (isNextWalkable) {
                    neighbors.push([x + dx, y]);
                    if (isTopWalkable) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (isBottomWalkable) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
                if (isTopWalkable) {
                    neighbors.push([x, y + 1]);
                }
                if (isBottomWalkable) {
                    neighbors.push([x, y - 1]);
                }
            }
            else if (dy !== 0) {
                isNextWalkable = grid.isWalkableAt(x, y + dy);
                var isRightWalkable = grid.isWalkableAt(x + 1, y);
                var isLeftWalkable = grid.isWalkableAt(x - 1, y);

                if (isNextWalkable) {
                    neighbors.push([x, y + dy]);
                    if (isRightWalkable) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (isLeftWalkable) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
                if (isRightWalkable) {
                    neighbors.push([x + 1, y]);
                }
                if (isLeftWalkable) {
                    neighbors.push([x - 1, y]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFMoveDiagonallyIfNoObstacles;

},{"../core/DiagonalMovement":6,"./JumpPointFinderBase":25}],23:[function(require,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = require('./JumpPointFinderBase');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm allowing only horizontal
 * or vertical movements.
 */
function JPFNeverMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();
JPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array.<[number, number]>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    if (dx !== 0) {
        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
            return [x, y];
        }
    }
    else if (dy !== 0) {
        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
            return [x, y];
        }
        //When moving vertically, must check for horizontal jump points
        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
            return [x, y];
        }
    }
    else {
        throw new Error("Only horizontal and vertical movements are allowed");
    }

    return this._jump(x + dx, y + dy, x, y);
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array.<[number, number]>} The neighbors found.
 */
JPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        if (dx !== 0) {
            if (grid.isWalkableAt(x, y - 1)) {
                neighbors.push([x, y - 1]);
            }
            if (grid.isWalkableAt(x, y + 1)) {
                neighbors.push([x, y + 1]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
        }
        else if (dy !== 0) {
            if (grid.isWalkableAt(x - 1, y)) {
                neighbors.push([x - 1, y]);
            }
            if (grid.isWalkableAt(x + 1, y)) {
                neighbors.push([x + 1, y]);
            }
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFNeverMoveDiagonally;

},{"../core/DiagonalMovement":6,"./JumpPointFinderBase":25}],24:[function(require,module,exports){
/**
 * @author aniero / https://github.com/aniero
 */
var DiagonalMovement = require('../core/DiagonalMovement');
var JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');
var JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');
var JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');
var JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');

/**
 * Path finder using the Jump Point Search algorithm
 * @param {object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal
 *      movement will be allowed.
 */
function JumpPointFinder(opt) {
    opt = opt || {};
    if (opt.diagonalMovement === DiagonalMovement.Never) {
        return new JPFNeverMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.Always) {
        return new JPFAlwaysMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        return new JPFMoveDiagonallyIfNoObstacles(opt);
    } else {
        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
    }
}

module.exports = JumpPointFinder;

},{"../core/DiagonalMovement":6,"./JPFAlwaysMoveDiagonally":20,"./JPFMoveDiagonallyIfAtMostOneObstacle":21,"./JPFMoveDiagonallyIfNoObstacles":22,"./JPFNeverMoveDiagonally":23}],25:[function(require,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var Heap       = require('heap');
var Util       = require('../core/Util');
var Heuristic  = require('../core/Heuristic');
var DiagonalMovement = require('../core/DiagonalMovement');

/**
 * Base class for the Jump Point Search algorithm
 * @param {object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function JumpPointFinderBase(opt) {
    opt = opt || {};
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.trackJumpRecursion = opt.trackJumpRecursion || false;
}

/**
 * Find and return the path.
 * @return {Array.<[number, number]>} The path, including both start and
 *     end positions.
 */
JumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = this.openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = this.startNode = grid.getNodeAt(startX, startY),
        endNode = this.endNode = grid.getNodeAt(endX, endY), node;

    this.grid = grid;


    // set the `g` and `f` value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        node.closed = true;

        if (node === endNode) {
            return Util.expandPath(Util.backtrace(endNode));
        }

        this._identifySuccessors(node);
    }

    // fail to find the path
    return [];
};

/**
 * Identify successors for the given node. Runs a jump point search in the
 * direction of each available neighbor, adding any points found to the open
 * list.
 * @protected
 */
JumpPointFinderBase.prototype._identifySuccessors = function(node) {
    var grid = this.grid,
        heuristic = this.heuristic,
        openList = this.openList,
        endX = this.endNode.x,
        endY = this.endNode.y,
        neighbors, neighbor,
        jumpPoint, i, l,
        x = node.x, y = node.y,
        jx, jy, dx, dy, d, ng, jumpNode,
        abs = Math.abs, max = Math.max;

    neighbors = this._findNeighbors(node);
    for(i = 0, l = neighbors.length; i < l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {

            jx = jumpPoint[0];
            jy = jumpPoint[1];
            jumpNode = grid.getNodeAt(jx, jy);

            if (jumpNode.closed) {
                continue;
            }

            // include distance, as parent may not be immediately adjacent:
            d = Heuristic.octile(abs(jx - x), abs(jy - y));
            ng = node.g + d; // next `g` value

            if (!jumpNode.opened || ng < jumpNode.g) {
                jumpNode.g = ng;
                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
                jumpNode.f = jumpNode.g + jumpNode.h;
                jumpNode.parent = node;

                if (!jumpNode.opened) {
                    openList.push(jumpNode);
                    jumpNode.opened = true;
                } else {
                    openList.updateItem(jumpNode);
                }
            }
        }
    }
};

module.exports = JumpPointFinderBase;

},{"../core/DiagonalMovement":6,"../core/Heuristic":8,"../core/Util":10,"heap":3}],26:[function(require,module,exports){
// PERLIN NOISE
// based 99.999% on Processing's implementation, found here:
// https://github.com/processing/processing/blob/master/core/src/processing/core/PApplet.java
// credit goes entirely to them. i just ported it to javascript.

var Alea = require("alea"); // this is pretty great, btw

var Perlin = module.exports = function(seed) {
	if (seed != undefined) {
		this.alea_rand = new Alea(seed); // use provided seed
	} else {
		this.alea_rand = new Alea(); // use random seed
	}
	this.PERLIN_YWRAPB = 4;
	this.PERLIN_YWRAP = 1 << this.PERLIN_YWRAPB;
	this.PERLIN_ZWRAPB = 8;
	this.PERLIN_ZWRAP = 1 << this.PERLIN_ZWRAPB;
	this.PERLIN_SIZE = 4095;
	this.perlin_octaves = 4; // default to medium smooth
	this.perlin_amp_falloff = 0.5; // 50% reduction/octave
	this.perlin_array = new Array();
	// generate cos lookup table
	var DEG_TO_RAD = 0.0174532925;
	var SINCOS_PRECISION = 0.5;
	var SINCOS_LENGTH = Math.floor(360/SINCOS_PRECISION);
	this.cosLUT = new Array();
	for (var i = 0; i < SINCOS_LENGTH; i++) {
		this.cosLUT[i] = Math.cos(i * DEG_TO_RAD * SINCOS_PRECISION);
	}
	this.perlin_TWOPI = SINCOS_LENGTH;
	this.perlin_PI = SINCOS_LENGTH;
	this.perlin_PI >>= 1;
}

Perlin.prototype.noiseReseed = function() {
	this.alea_rand = new Alea(); // new random seed
	this.perlin_array = new Array(); // start the perlin array fresh
}

Perlin.prototype.noiseSeed = function(seed) {
	this.alea_rand = new Alea(seed); // use provided seed
	this.perlin_array = new Array(); // start the perlin array fresh
}


Perlin.prototype.noiseDetail = function(lod, falloff) {
	if (Math.floor(lod) > 0) this.perlin_octaves = Math.floor(lod);
	if (falloff != undefined && falloff > 0) this.perlin_amp_falloff = falloff;
}

Perlin.prototype.noise_fsc = function(i) {
	return 0.5 * (1.0 - this.cosLUT[Math.floor(i * this.perlin_PI) % this.perlin_TWOPI]);
}

Perlin.prototype.noise = function(x, y, z) {
	if (x == undefined) {
		return false; // we need at least one param
	}
	if (y == undefined) {
		y = 0; // use 0 if not provided
	}
	if (z == undefined) {
		z = 0; // use 0 if not provided
	}
	
	// build the first perlin array if there isn't one
	if (this.perlin_array.length == 0) {
		this.perlin_array = new Array();
		for (var i = 0; i < this.PERLIN_SIZE + 1; i++) {
			this.perlin_array[i] = this.alea_rand();
		}
	}

	if (x < 0) x = -x;
	if (y < 0) y = -y;
	if (z < 0) z = -z;
	var xi = Math.floor(x);
	var yi = Math.floor(y);
	var zi = Math.floor(z);
	var xf = x - xi;
	var yf = y - yi;
	var zf = z - zi;
	var r = 0;
	var ampl = 0.5;
	var rxf, ryf, n1, n2, n3;
	
	for (var i = 0; i < this.perlin_octaves; i++) {
		// look at all this math stuff
		var of = xi + (yi << this.PERLIN_YWRAPB) + (zi << this.PERLIN_ZWRAPB);
		rxf = this.noise_fsc(xf);
		ryf = this.noise_fsc(yf);
		n1  = this.perlin_array[of & this.PERLIN_SIZE];
		n1 += rxf * (this.perlin_array[(of + 1) & this.PERLIN_SIZE] - n1);
		n2  = this.perlin_array[(of + this.PERLIN_YWRAP) & this.PERLIN_SIZE];
		n2 += rxf * (this.perlin_array[(of + this.PERLIN_YWRAP + 1) & this.PERLIN_SIZE] - n2);
		n1 += ryf * (n2-n1);
		of += this.PERLIN_ZWRAP;
		n2  = this.perlin_array[of & this.PERLIN_SIZE];
		n2 += rxf * (this.perlin_array[(of + 1) & this.PERLIN_SIZE] - n2);
		n3  = this.perlin_array[(of + this.PERLIN_YWRAP) & this.PERLIN_SIZE];
		n3 += rxf * (this.perlin_array[(of + this.PERLIN_YWRAP + 1) & this.PERLIN_SIZE] - n3);
		n2 += ryf * (n3 - n2);
		n1 += this.noise_fsc(zf) * (n2 - n1);
		r += n1 * ampl;
		ampl *= this.perlin_amp_falloff;
		xi <<= 1;
		xf *= 2;
		yi <<= 1;
		yf *= 2;
		zi <<= 1; 
		zf *= 2;
		if (xf >= 1) { xi++; xf--; }
		if (yf >= 1) { yi++; yf--; }
		if (zf >= 1) { zi++; zf--; }
	}
	return r;
}

},{"alea":27}],27:[function(require,module,exports){
(function (root, factory) {
  if (typeof exports === 'object') {
      module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
      define(factory);
  } else {
      root.Alea = factory();
  }
}(this, function () {

  'use strict';

  // From http://baagoe.com/en/RandomMusings/javascript/

  // importState to sync generator states
  Alea.importState = function(i){
    var random = new Alea();
    random.importState(i);
    return random;
  };

  return Alea;

  function Alea() {
    return (function(args) {
      // Johannes Baagøe <baagoe@baagoe.com>, 2010
      var s0 = 0;
      var s1 = 0;
      var s2 = 0;
      var c = 1;

      if (args.length == 0) {
        args = [+new Date];
      }
      var mash = Mash();
      s0 = mash(' ');
      s1 = mash(' ');
      s2 = mash(' ');

      for (var i = 0; i < args.length; i++) {
        s0 -= mash(args[i]);
        if (s0 < 0) {
          s0 += 1;
        }
        s1 -= mash(args[i]);
        if (s1 < 0) {
          s1 += 1;
        }
        s2 -= mash(args[i]);
        if (s2 < 0) {
          s2 += 1;
        }
      }
      mash = null;

      var random = function() {
        var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
        s0 = s1;
        s1 = s2;
        return s2 = t - (c = t | 0);
      };
      random.uint32 = function() {
        return random() * 0x100000000; // 2^32
      };
      random.fract53 = function() {
        return random() + 
          (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
      };
      random.version = 'Alea 0.9';
      random.args = args;

      // my own additions to sync state between two generators
      random.exportState = function(){
        return [s0, s1, s2, c];
      };
      random.importState = function(i){
        s0 = +i[0] || 0;
        s1 = +i[1] || 0;
        s2 = +i[2] || 0;
        c = +i[3] || 0;
      };
 
      return random;

    } (Array.prototype.slice.call(arguments)));
  }

  function Mash() {
    var n = 0xefc8249d;

    var mash = function(data) {
      data = data.toString();
      for (var i = 0; i < data.length; i++) {
        n += data.charCodeAt(i);
        var h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000; // 2^32
      }
      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    };

    mash.version = 'Mash 0.9';
    return mash;
  }
}));

},{}],28:[function(require,module,exports){
/*! qwest 1.5.4 (https://github.com/pyrsmk/qwest) */

;(function(context,name,definition){
	if(typeof module!='undefined' && module.exports){
		module.exports=definition;
	}
	else if(typeof define=='function' && define.amd){
		define(definition);
	}
	else{
		context[name]=definition;
	}
}(this,'qwest',function(){

	var win=window,
		doc=document,
		before,
		// Default response type for XDR in auto mode
		defaultXdrResponseType='json',
		// Variables for limit mechanism
		limit=null,
		requests=0,
		request_stack=[],
		// Get XMLHttpRequest object
		getXHR=function(){
				return win.XMLHttpRequest?
						new XMLHttpRequest():
						new ActiveXObject('Microsoft.XMLHTTP');
			},
		// Guess XHR version
		xhr2=(getXHR().responseType===''),

	// Core function
	qwest=function(method,url,data,options,before){

		// Format
		method=method.toUpperCase();
		data=data || null;
		options=options || {};

		// Define variables
		var nativeResponseParsing=false,
			crossOrigin,
			xhr,
			xdr=false,
			timeoutInterval,
			aborted=false,
			retries=0,
			headers={},
			mimeTypes={
				text: '*/*',
				xml: 'text/xml',
				json: 'application/json',
				arraybuffer: null,
				formdata: null,
				document: null,
				file: null,
				blob: null
			},
			contentType='Content-Type',
			vars='',
			i,j,
			serialized,
			then_stack=[],
			catch_stack=[],
			complete_stack=[],
			response,
			success,
			error,
			func,

		// Define promises
		promises={
			then:function(func){
				if(options.async){
					then_stack.push(func);
				}
				else if(success){
					func.call(xhr,response);
				}
				return promises;
			},
			'catch':function(func){
				if(options.async){
					catch_stack.push(func);
				}
				else if(error){
					func.call(xhr,response);
				}
				return promises;
			},
			complete:function(func){
				if(options.async){
					complete_stack.push(func);
				}
				else{
					func.call(xhr);
				}
				return promises;
			}
		},
		promises_limit={
			then:function(func){
				request_stack[request_stack.length-1].then.push(func);
				return promises_limit;
			},
			'catch':function(func){
				request_stack[request_stack.length-1]['catch'].push(func);
				return promises_limit;
			},
			complete:function(func){
				request_stack[request_stack.length-1].complete.push(func);
				return promises_limit;
			}
		},

		// Handle the response
		handleResponse=function(){
			// Verify request's state
			// --- https://stackoverflow.com/questions/7287706/ie-9-javascript-error-c00c023f
			if(aborted){
				return;
			}
			// Prepare
			var i,req,p,responseType;
			--requests;
			// Clear the timeout
			clearInterval(timeoutInterval);
			// Launch next stacked request
			if(request_stack.length){
				req=request_stack.shift();
				p=qwest(req.method,req.url,req.data,req.options,req.before);
				for(i=0;func=req.then[i];++i){
					p.then(func);
				}
				for(i=0;func=req['catch'][i];++i){
					p['catch'](func);
				}
				for(i=0;func=req.complete[i];++i){
					p.complete(func);
				}
			}
			// Handle response
			try{
				// Verify status code
				// --- https://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
				if('status' in xhr && !/^2|1223/.test(xhr.status)){
					throw xhr.status+' ('+xhr.statusText+')';
				}
				// Init
				var responseText='responseText',
					responseXML='responseXML',
					parseError='parseError';
				// Process response
				if(nativeResponseParsing && 'response' in xhr && xhr.response!==null){
					response=xhr.response;
				}
				else if(options.responseType=='document'){
					var frame=doc.createElement('iframe');
					frame.style.display='none';
					doc.body.appendChild(frame);
					frame.contentDocument.open();
					frame.contentDocument.write(xhr.response);
					frame.contentDocument.close();
					response=frame.contentDocument;
					doc.body.removeChild(frame);
				}
				else{
					// Guess response type
					responseType=options.responseType;
					if(responseType=='auto'){
						if(xdr){
							responseType=defaultXdrResponseType;
						}
						else{
							switch(xhr.getResponseHeader(contentType)){
								case mimeTypes.json:
									responseType='json';
									break;
								case mimeTypes.xml:
									responseType='xml';
									break;
								default:
									responseType='text';
							}
						}
					}
					// Handle response type
					switch(responseType){
						case 'json':
							try{
								if('JSON' in win){
									response=JSON.parse(xhr[responseText]);
								}
								else{
									response=eval('('+xhr[responseText]+')');
								}
							}
							catch(e){
								throw "Error while parsing JSON body : "+e;
							}
							break;
						case 'xml':
							// Based on jQuery's parseXML() function
							try{
								// Standard
								if(win.DOMParser){
									response=(new DOMParser()).parseFromString(xhr[responseText],'text/xml');
								}
								// IE<9
								else{
									response=new ActiveXObject('Microsoft.XMLDOM');
									response.async='false';
									response.loadXML(xhr[responseText]);
								}
							}
							catch(e){
								response=undefined;
							}
							if(!response || !response.documentElement || response.getElementsByTagName('parsererror').length){
								throw 'Invalid XML';
							}
							break;
						default:
							response=xhr[responseText];
					}
				}
				// Execute 'then' stack
				success=true;
				p=response;
				if(options.async){
					for(i=0;func=then_stack[i];++i){
						p=func.call(xhr,p);
					}
				}
			}
			catch(e){
				error=true;
				// Execute 'catch' stack
				if(options.async){
					for(i=0;func=catch_stack[i];++i){
						func.call(xhr,e+' ('+url+')');
					}
				}
			}
			// Execute complete stack
			if(options.async){
				for(i=0;func=complete_stack[i];++i){
					func.call(xhr);
				}
			}
		},

		// Recursively build the query string
		buildData=function(data,key){
			var res=[],
				enc=encodeURIComponent,
				p;
			if(typeof data==='object' && data!=null) {
				for(p in data) {
					if(data.hasOwnProperty(p)) {
						var built=buildData(data[p],key?key+'['+p+']':p);
						if(built!==''){
							res=res.concat(built);
						}
					}
				}
			}
			else if(data!=null && key!=null){
				res.push(enc(key)+'='+enc(data));
			}
			return res.join('&');
		};

		// New request
		++requests;

		// Normalize options
		options.async='async' in options?!!options.async:true;
		options.cache='cache' in options?!!options.cache:(method!='GET');
		options.dataType='dataType' in options?options.dataType.toLowerCase():'post';
		options.responseType='responseType' in options?options.responseType.toLowerCase():'auto';
		options.user=options.user || '';
		options.password=options.password || '';
		options.withCredentials=!!options.withCredentials;
		options.timeout=options.timeout?parseInt(options.timeout,10):3000;
		options.retries=options.retries?parseInt(options.retries,10):3;

		// Guess if we're dealing with a cross-origin request
		i=url.match(/\/\/(.+?)\//);
		crossOrigin=i && i[1]?i[1]!=location.host:false;

		// Prepare data
		if('ArrayBuffer' in win && data instanceof ArrayBuffer){
			options.dataType='arraybuffer';
		}
		else if('Blob' in win && data instanceof Blob){
			options.dataType='blob';
		}
		else if('Document' in win && data instanceof Document){
			options.dataType='document';
		}
		else if('FormData' in win && data instanceof FormData){
			options.dataType='formdata';
		}
		switch(options.dataType){
			case 'json':
				data=JSON.stringify(data);
				break;
			case 'post':
				data=buildData(data);
		}

		// Prepare headers
		if(options.headers){
			var format=function(match,p1,p2){
				return p1+p2.toUpperCase();
			};
			for(i in options.headers){
				headers[i.replace(/(^|-)([^-])/g,format)]=options.headers[i];
			}
		}
		if(!headers[contentType] && method!='GET'){
			if(options.dataType in mimeTypes){
				if(mimeTypes[options.dataType]){
					headers[contentType]=mimeTypes[options.dataType];
				}
			}
			else{
				headers[contentType]='application/x-www-form-urlencoded';
			}
		}
		if(!headers.Accept){
			headers.Accept=(options.responseType in mimeTypes)?mimeTypes[options.responseType]:'*/*';
		}
		if(!crossOrigin && !headers['X-Requested-With']){ // because that header breaks in legacy browsers with CORS
			headers['X-Requested-With']='XMLHttpRequest';
		}

		// Prepare URL
		if(method=='GET'){
			vars+=data;
		}
		if(!options.cache){
			if(vars){
				vars+='&';
			}
			vars+='__t='+(+new Date());
		}
		if(vars){
			url+=(/\?/.test(url)?'&':'?')+vars;
		}

		// The limit has been reached, stock the request
		if(limit && requests==limit){
			request_stack.push({
				method	: method,
				url		: url,
				data	: data,
				options	: options,
				before	: before,
				then	: [],
				'catch'	: [],
				complete: []
			});
			return promises_limit;
		}

		// Send the request
		var send=function(){
			// Get XHR object
			xhr=getXHR();
			if(crossOrigin){
				if(!('withCredentials' in xhr) && win.XDomainRequest){
					xhr=new XDomainRequest(); // CORS with IE8/9
					xdr=true;
					if(method!='GET' && method!='POST'){
						method='POST';
					}
				}
			}
			// Open connection
			if(xdr){
				xhr.open(method,url);
			}
			else{
				xhr.open(method,url,options.async,options.user,options.password);
				if(xhr2 && options.async){
					xhr.withCredentials=options.withCredentials;
				}
			}
			// Set headers
			if(!xdr){
				for(var i in headers){
					xhr.setRequestHeader(i,headers[i]);
				}
			}
			// Verify if the response type is supported by the current browser
			if(xhr2 && options.responseType!='document'){ // Don't verify for 'document' since we're using an internal routine
				try{
					xhr.responseType=options.responseType;
					nativeResponseParsing=(xhr.responseType==options.responseType);
				}
				catch(e){}
			}
			// Plug response handler
			if(xhr2 || xdr){
				xhr.onload=handleResponse;
			}
			else{
				xhr.onreadystatechange=function(){
					if(xhr.readyState==4){
						handleResponse();
					}
				};
			}
			// Override mime type to ensure the response is well parsed
			if(options.responseType!=='auto' && 'overrideMimeType' in xhr){
				xhr.overrideMimeType(mimeTypes[options.responseType]);
			}
			// Run 'before' callback
			if(before){
				before.call(xhr);
			}
			// Send request
			if(xdr){
				setTimeout(function(){ // https://developer.mozilla.org/en-US/docs/Web/API/XDomainRequest
					xhr.send();
				},0);
			}
			else{
				xhr.send(method!='GET'?data:null);
			}
		};

		// Timeout/retries
		var timeout=function(){
			timeoutInterval=setTimeout(function(){
				aborted=true;
				xhr.abort();
				if(!options.retries || ++retries!=options.retries){
					aborted=false;
					timeout();
					send();
				}
				else{
					aborted=false;
					error=true;
					response='Timeout ('+url+')';
					if(options.async){
						for(i=0;func=catch_stack[i];++i){
							func.call(xhr,response);
						}
					}
				}
			},options.timeout);
		};

		// Start the request
		timeout();
		send();

		// Return promises
		return promises;

	};

	// Return external qwest object
	var create=function(method){
			return function(url,data,options){
				var b=before;
				before=null;
				return qwest(method,url,data,options,b);
			};
		},
		obj={
			before: function(callback){
				before=callback;
				return obj;
			},
			get: create('GET'),
			post: create('POST'),
			put: create('PUT'),
			'delete': create('DELETE'),
			xhr2: xhr2,
			limit: function(by){
				limit=by;
			},
			setDefaultXdrResponseType: function(type){
				defaultXdrResponseType=type.toLowerCase();
			}
		};
	return obj;

}()));

},{}],29:[function(require,module,exports){
"use strict";

// Config loads and prepares the config file. The modules that does the
// actual transformations of the dataset are located in transforms/config.

var type    = require('./utils/type.js');
var config  = null;
var qwest   = require('qwest');

module.exports = {
    // Pass a list of string arguments as the full path for the object
    // you're looking for. E.g.: 'tilesets', 'space', 'tiles' for the
    // tile settings for the space tileset.
    get: function() {
        var args = Array.prototype.slice.call(arguments);
        if (args.length === 0) {
            return null;
        }
        if (config == null) {
            console.log('config is empty');
            return null;
        }
        return crawl(args);
    },

    load: function(callback) {
        var cb = function(value) {
            if (!type(callback).is_undefined) {
                callback(value);
            }
        };

        // TODO: both name of config file and port number should
        // be inserted by Yeoman(?). Maybe the settings can be
        // stored in package.json?
        qwest.get('http://localhost:5000/config.json')
            .then(function(response) {
                config = response;

                // var pipeline = require('transforms/pipeline');
                // var transforms = require('transforms/config/index');

                // pipeline(config)
                //     .pipe(transforms.tileset_index_range)
                //     .pipe(transforms.tile_settings);

                cb(true);
            })
            .catch(function(message) {
                console.error(message);
                cb(false);
            });
    }
};

function crawl(args) {
    var arg = '';
    var obj = config;

    // TODO: Use Array foreach instead

    for (var i=0, j=args.length; i<j; i++) {
        arg = args[i];
        obj = obj[arg];
        if (type(obj).is_undefined) {
            console.warn('Config cannot find '+args.join('.'));
            return null;
        }
    }
    return obj;
}

},{"./utils/type.js":64,"qwest":28}],30:[function(require,module,exports){
"use strict";

var config = require('./config.js');

module.exports.getDataTypeValue = function(name) {
    var data_types = config.get('map', 'data_types');
    var dt = null;
    for (var i=0; i<data_types.length; i++) {
        dt = data_types[i];
        if (dt.name === name) {
            break;
        }
    }
    return dt.value;
}

module.exports.getDataType = function(value) {
    var data_types = config.get('map', 'data_types');
    var dt = null;
    for (var i=0; i<data_types.length; i++) {
        dt = data_types[i];
        if (dt.value === value) {
            break;
        }
    }
    return dt.name;
}

},{"./config.js":29}],31:[function(require,module,exports){
"use strict";

var config          = require('./../config.js');
var type            = require('./../utils/type.js');

var keys = {};
var key_codes = [];
var states = {};
var pointer;
var game;

module.exports.init = function(g) {
    game = g;

    registerKeys(config.get('input', 'keys'));
    pointer = game.input.activePointer;

    // Stop the key events from propagating up to the browser
    game.input.keyboard.addKeyCapture(key_codes);
}

module.exports.keys = function(name) {
    return keys[name];
}

function registerKeys(keys_config) {
    Object.keys(keys_config).forEach(function(name) {
        var settings = keys_config[name];
        addKey(settings.key_code, name);

        Object.defineProperty(module.exports, name, {
            get: function() { return keys[name]; }
        });
    });
}

function addKey(key_code, name) {
    key_codes.push(Phaser.Keyboard[key_code]);
    keys[name] = game.input.keyboard.addKey(key_codes[key_codes.length-1]);
    keys[name].name = name;
}

Object.defineProperty(module.exports, 'pointer', {
    get: function() { return pointer; }
});

},{"./../config.js":29,"./../utils/type.js":64}],32:[function(require,module,exports){
"use strict";

var config          = require('./../config.js');
var type            = require('./../utils/type.js');
var list            = require('./../utils/list.js');

var level_config;
var map;
var layers = {};

module.exports.createMap = function(game, options) {
    if (type(options).is_undefined) {
        console.log('Level controller needs certain options to work');
        return null;
    }

    level_config = config.get('level');

    var debug = options.debug || level_config.debug;
    var name = options.name || 'Unnamed';

    if (type(options.data).is_array) {
        options.data = list.printString(options.data);
    }

    if (type(options.tileset).is_undefined) {
        options.tileset = level_config.tileset;
    }

    createMap(game, options);

    return this.addLayer(options.name, debug);
};

module.exports.addLayer = function(name, debug) {
    if (type(layers[name]).is_undefined) {
        layers[name] = addLayer(debug);
    }
    return layers[name];
};

module.exports.getLayer = function(name) {
    return layers[name];
};

module.exports.removeLayer = function(game, name) {
    var layer = layers[name];
    layer.destroy();
    layers[name] = undefined;
};

module.exports.setCollision = function(include) {
    if (!type(include).is_array &&
        !type(include).is_number) {
        console.log('Includes must be either a number or an array');
        return;
    }

    var excludes = map.collideIndexes.map(function(index) {
        return index;
    });
    map.setCollision(excludes, false);
    map.setCollision(include, true);
};

Object.defineProperty(module.exports, 'map', {
    get: function() { return map; }
});

function addLayer(debug) {
    var index = 0;
    if (!type(Object(layers).keys).is_undefined) {
        index = Object(layers).keys.length;
    }
    var layer = map.createLayer(index);
    layer.resizeWorld();
    layer.debug = debug;
    return layer;
}

function createMap(game, options) {
    options.tile_size = options.tile_size || 16;
    options.layer_index = options.layer_index || 0;

    game.load.tilemap('map', null, options.data);
    map = game.add.tilemap('map', options.tile_size, options.tile_size);
    map.addTilesetImage(options.tileset);
}

},{"./../config.js":29,"./../utils/list.js":63,"./../utils/type.js":64}],33:[function(require,module,exports){
"use strict";

var type = require('./../utils/type.js');

module.exports.add = function(owner, name, callback) {
    if (type(owner.__states).is_undefined) {
        owner.__states = {};
    }
    owner.__states[name] = callback;
}

module.exports.set = function(owner, name, options) {
    if (!type(owner.__states).is_object) {
        return;
    }

    if (type(name).is_array) {
        for (var i=0; i<name.length; i++) {
            if (!type(owner.__states[name[i]]).is_undefined) {
                owner.__current_state_options = options;
                owner.__current_state = owner.__states[name[i]];
                return;
            }
        }
    }

    if (!type(owner.__states[name]).is_undefined) {
        owner.__current_state_options = options;
        owner.__current_state = owner.__states[name];
    }
}

module.exports.current = function(owner) {
    owner.__current_state(owner.__current_state_options);
}

},{"./../utils/type.js":64}],34:[function(require,module,exports){
"use strict";

var list    = require('./../utils/list.js');
var type    = require('./../utils/type.js');
var PF      = require('pathfinding');

function Grid(width, height, value) {
    var w = width;
    var h = height;
    var pathfinder = null;
    var finder = null;

    var instance = {
        data:           [],
        tiles:          [],
        name:           'Unnamed',
        seed:           1,
        meta:           {},
        // Has to be 2D array due to the pathfinding library
        pathf_data:     [],

        init: function(value) {
            value = value || 0;
            for (var i=0, l=w * h; i<l; i++) {
                this.data.push(value);
                this.tiles.push(value);
            }
        },

        generatePathfindingData: function(walkables) {
            if (!type(walkables).is_array) {
                if (!type(walkables).is_number) {
                    console.log('generatePathfindingData needs an array or '+
                                'an integer.');
                    return;
                } else {
                    walkables = [walkables];
                }
            }

            var row = [];
            // list.each(this.data, w, function(tile, x, y, i) {
            this.data.each(w, function(tile, x, y, i) {
                row.push(walkables.indexOf(tile) >= 0 ? 0 : 1);
                if (x === w - 1) {
                    this.pathf_data.push(row);
                    row = [];
                }
            }.bind(this));

            finder = new PF.JumpPointFinder();
        },

        findPath: function(from_x, from_y, to_x, to_y) {
            if (pathfinder === null) {
                pathfinder = new PF.Grid(w,
                                         this.pathf_data.length,
                                         this.pathf_data);
            } else {
                pathfinder = pathfinder.clone();
            }

            return finder.findPath(from_x, from_y, to_x, to_y, pathfinder);
        }

    };

    if (typeof value !== 'undefined') {
        instance.init(value);
    }

    get(instance, 'width', function() {
        return w;
    });

    get(instance, 'height', function() {
        return this.data.length / w;
    });

    get(instance, 'length', function() {
        return this.data.length;
    });

    return instance;
}

function get(obj, prop, cb) {
    Object.defineProperty(obj, prop, {
        get: cb,
        enumerable: true
    });
}

function set(obj, prop, cb) {
    Object.defineProperty(obj, prop, {
        set:        cb,
        enumerable: true
    });
}

function getset(obj, prop, get_cb, set_cb) {
    Object.defineProperty(obj, prop, {
        // get:        get_cb,
        // set:        set_cb,
        enumerable: true,
        writable:   true,
        configurable:   true
    });
}

module.exports.create = function(width, height, value) {
    return new Grid(width, height, value);
}

},{"./../utils/list.js":63,"./../utils/type.js":64,"pathfinding":2}],35:[function(require,module,exports){
"use strict";

// NOTES
// - Turning radius should be a factor of speed. Greater radius at greater
//   speeds.
// - Use the angle of the rotation to switch between sprites.

var config          = require('./../config.js');
var input           = require('./../controllers/input.js');
var states          = require('./../controllers/states.js');
var physics         = require('./../helpers/phaser/physics.js');
var player          = require('./player.js');
var type            = require('./../utils/type.js');

var speed_rotate = 90;
var speed_forward = 40;
var game;
var boat;
var hull;
var sails;
var sail_up = 1;
var sail_down = 2;
var sail_is_up = false;
var layer;

module.exports.init = function(g, l) {
    game = g;
    layer = l;

    boat = game.add.sprite();
    boat.name = 'boat';

    states.add(this, 'dock', dock);
    states.add(this, 'idle', idle);

    hull = boat.addChild(game.make.sprite(0, 0, 'sprites-16'));
    hull.anchor.setTo(0.5, 0.5);
    hull.frame = 0;
    hull.name = 'hull';

    sails = boat.addChild(game.make.sprite(0, 0, 'sprites-16'));
    sails.anchor.setTo(0.5, 1);
    sails.x += 1;
    sails.name = 'sails';

    boat.anchor.setTo(0.5, 0.5);

    physics.enable(boat);
    physics.enable(hull);

    boat.body.setSize(12, 12, 0, 0);

    this.hide();

    return this;
};

module.exports.update = function() {
    physics.collide(boat, layer);
    states.current(this);

    boat.body.velocity.x *= 0.9;
    boat.body.velocity.y *= 0.9;
    hull.body.angularVelocity *= 0.9;

    sail_is_up = input.up.isDown ? true : false;
    sails.frame = sail_is_up ? sail_up : sail_down;

    if (sail_is_up) {
        game.physics.arcade.accelerationFromRotation(hull.rotation,
                                                     speed_forward,
                                                     boat.body.velocity);
    }

    if (input.right.isDown) {
        hull.body.angularVelocity = speed_rotate;
    } else if (input.left.isDown) {
        hull.body.angularVelocity = -speed_rotate;
    }
};

module.exports.show = function(x, y) {
    // TODO: get the tile's halfsize from somewhere
    if (type(x).is_undefined) {
        x = boat.x;
    } else {
        x = x + 8;
    }

    if (type(y).is_undefined) {
        y = boat.y;
    } else {
        y = y + 8;
    }

    boat.x = x;
    boat.y = y;
    boat.visible = true;
    states.set(this, 'sailing');
}

module.exports.hide = function() {
    boat.visible = false;
    states.set(this, 'idle');
}

module.exports.onPier = function(pier) {
    boat.body.velocity.setTo(0, 0);
    player.switchTo('fisherman', false);
    player.current.show(pier.position.x, pier.position.y);
}

// TODO: obsolete
function idle() {}
function dock(pier) {}

Object.defineProperty(module.exports, 'sprite', {
    get: function() { return boat; },
    enumerable: true
});

Object.defineProperty(module.exports, 'settings', {
    get: function() { return settings; },
    enumerable: true
});

},{"./../config.js":29,"./../controllers/input.js":31,"./../controllers/states.js":33,"./../helpers/phaser/physics.js":46,"./../utils/type.js":64,"./player.js":39}],36:[function(require,module,exports){
"use strict";

module.exports.triggerEnter = function(other) {}
module.exports.triggerLeave = function(other) {}
module.exports.triggerStay = function(other) {}

},{}],37:[function(require,module,exports){
"use strict";

var config          = require('./../config.js');
var input           = require('./../controllers/input.js');
var states          = require('./../controllers/states.js');
var physics         = require('./../helpers/phaser/physics.js');
var player          = require('./player.js');
var type            = require('./../utils/type.js');

var fisherman;
var game;
var player_cfg;
var layer;

module.exports.init = function(g, l) {
    game = g;
    layer = l;

    player_cfg = config.get('entities', 'player');

    // TODO: obsolete
    states.add(this, 'idle', idle);

    fisherman = game.add.sprite(0, 0, 'sprites-16');
    fisherman.anchor.setTo(0.5, 0);
    fisherman.frame = 3;
    fisherman.name = 'fisherman';

    physics.enable(fisherman);
    fisherman.body.setSize(12, 12, 0, 4);

    this.hide();

    return this;
};

module.exports.update = function() {
    physics.collide(fisherman, layer);
    states.current(this);

    fisherman.body.velocity.x *= 0.2;
    fisherman.body.velocity.y *= 0.2;

    if (input.up.isDown) {
        fisherman.body.velocity.y = -player_cfg.speed;
    } else if (input.down.isDown) {
        fisherman.body.velocity.y = player_cfg.speed;
    }

    if (input.left.isDown) {
        fisherman.body.velocity.x = -player_cfg.speed;
    } else if (input.right.isDown) {
        fisherman.body.velocity.x = player_cfg.speed;
    }
};

module.exports.show = function(x, y) {
    if (type(x).is_undefined) {
        x = fisherman.x;
    } else {
        x = x + 8;
    }

    if (type(y).is_undefined) {
        y = fisherman.y;
    }

    fisherman.x = x;
    fisherman.y = y;
    fisherman.visible = true;
    states.set(this, 'walking');
}

module.exports.hide = function() {
    fisherman.visible = false;
    states.set(this, 'idle');
}

module.exports.onPier = function(pier) {
    fisherman.body.velocity.setTo(0, 0);
    player.switchTo('boat', true);
    player.current.show();
}

// TODO: obsolete
function idle() {}
function board() {}

Object.defineProperty(module.exports, 'sprite', {
    get: function() { return fisherman; },
    enumerable: true
});

Object.defineProperty(module.exports, 'settings', {
    get: function() { return settings; },
    enumerable: true
});

},{"./../config.js":29,"./../controllers/input.js":31,"./../controllers/states.js":33,"./../helpers/phaser/physics.js":46,"./../utils/type.js":64,"./player.js":39}],38:[function(require,module,exports){
"use strict";

var physics         = require('./../helpers/phaser/physics.js');
var ui              = require('./../ui/ui_manager.js');
var extend          = require('./../utils/extend.js');
var entity          = require('./entity.js');

var bounds;
var position;
var actions = ['dock', 'board'];

extend(module.exports, entity);

module.exports.create = function(tileWidth, tileHeight, spawn_pos) {
    var x = (tileWidth * spawn_pos.x) - tileWidth;
    var y = (tileHeight * spawn_pos.y) - tileHeight;

    position = {
        x: spawn_pos.x * tileWidth,
        y: spawn_pos.y * tileHeight
    };
    bounds = new Phaser.Rectangle(x, y, tileWidth * 3, tileHeight * 3);
    physics.addTrigger(this, 'pier');
}

module.exports.triggerEnter = function(player) {
    ui.dispatch('action_label', 'Dock');
}

module.exports.triggerLeave = function(player) {
    ui.dispatch('action_label');
}

Object.defineProperty(module.exports, 'bounds', {
    get: function() { return bounds; },
    enumerable: true
});

Object.defineProperty(module.exports, 'position', {
    get: function() { return position; },
    enumerable: true
});

Object.defineProperty(module.exports, 'actions', {
    get: function() { return actions; },
    enumerable: true
});

},{"./../helpers/phaser/physics.js":46,"./../ui/ui_manager.js":59,"./../utils/extend.js":61,"./entity.js":36}],39:[function(require,module,exports){
"use strict";

var cu              = require('./../config_utils.js');
var config          = require('./../config.js');
var states          = require('./../controllers/states.js');
var level           = require('./../controllers/level.js');
var input           = require('./../controllers/input.js');
var entity          = require('./entity.js');
var boat            = require('./boat.js');
var fisherman       = require('./fisherman.js');
var events          = require('./../events.js');
var physics         = require('./../helpers/phaser/physics.js');
var update          = require('./../helpers/phaser/update.js');
var list            = require('./../utils/list.js');
var extend          = require('./../utils/extend.js');
var type            = require('./../utils/type.js');

var current;
var players = {};
var game;
var collision_cfg;

extend(module.exports, entity);

module.exports.init = function(g, options) {
    game = g;

    collision_cfg = config.get('level', 'collisions');

    players['fisherman'] = fisherman.init(game, options.layer);
    players['boat'] = boat.init(game, options.layer);

    this.switchTo('boat');
    current.show(options.tile_width * options.spawn_pos.x,
                 options.tile_height * options.spawn_pos.y);

    // TODO: physics shouldn't be dependent on player.
    physics.setPlayer(this);
    update.register(this);

    input.action.onUp.add(onAction);
}

module.exports.update = function() {
    current.update();
}

module.exports.switchTo = function(target, hide) {
    if (type(hide).is_undefined) {
        hide = true;
    }
    if (current && hide) {
        current.hide();
    }
    current = players[target];
    level.setCollision(collision_cfg[target]);
    events.onPlayerChange.dispatch(target);
}

module.exports.triggerEnter = function(entity) {
    // TODO: obsolete
    states.set(current, entity.actions, entity);
}

module.exports.triggerLeave = function(entity) {
    // TODO: obsolete
    states.set(current, 'idle');
}

function onAction() {
    if (physics.triggers.pier.active) {
        current.onPier(physics.triggers.pier.owner);
    }
}

Object.defineProperty(module.exports, 'current', {
    get: function() { return current; },
    enumerable: true
});


},{"./../config.js":29,"./../config_utils.js":30,"./../controllers/input.js":31,"./../controllers/level.js":32,"./../controllers/states.js":33,"./../events.js":40,"./../helpers/phaser/physics.js":46,"./../helpers/phaser/update.js":47,"./../utils/extend.js":61,"./../utils/list.js":63,"./../utils/type.js":64,"./boat.js":35,"./entity.js":36,"./fisherman.js":37}],40:[function(require,module,exports){
"use strict";

var on_player_change = new Phaser.Signal();

Object.defineProperty(module.exports, 'onPlayerChange', {
    get: function() { return on_player_change; },
    enumerable: true
});

},{}],41:[function(require,module,exports){
"use strict";

var config      = require('./config.js');
var dom         = require('./utils/dom.js');
var game_config = null;

// TODO: Add new states via Yeoman. This list needs to be dynamically
// recreated.

var boot        = require('./states/boot.js');
var preloader   = require('./states/preloader.js');
var generate    = require('./states/generate.js');
var worldmap    = require('./states/worldmap.js');
var boat        = require('./states/boat.js');
var game_state  = require('./states/game.js');

module.exports = function() {
    config.load(function() {
        game_config = config.get('game');
        dom.add_game_node();

        var game = new Phaser.Game(game_config.width, game_config.height,
                                   Phaser.CANVAS,
                                   game_config.dom_element_id,
                                   null, false, false);

        game.state.add('Boot',      boot);
        game.state.add('Preloader', preloader);
        game.state.add('Generate',  generate);
        game.state.add('Worldmap',  worldmap);
        game.state.add('Game',      game_state);
        game.state.add('Boat',      boat);

        game.state.start(config.get('game', 'boot_sequence').next());
    });
}

},{"./config.js":29,"./states/boat.js":48,"./states/boot.js":49,"./states/game.js":50,"./states/generate.js":51,"./states/preloader.js":52,"./states/worldmap.js":53,"./utils/dom.js":60}],42:[function(require,module,exports){
var list        = require('./../utils/list.js');
// var inverter    = require('transforms/grid/inverter');
// var rooms       = require('transforms/grid/rooms');

var data = null;
var data_string = null;
var options = {};

module.exports = {
    generate: function(grid, opt) {
        options = opt || {
            seed:       1,
            smoothness: 1,
            padding:    1,
            value_a:    0,
            value_b:    1
        };

        Math.seed = options.seed;

        grid.data.each(grid.width, function(value, x, y, i) {
        // list.each(grid.data, grid.width, function(item, x, y, i) {
            if ((x < options.padding) ||
                (y < options.padding) ||
                (x >= grid.width - options.padding) ||
                (y >= grid.width - options.padding)) {
                grid.data[i] = 0;
            } else {
                grid.data[i] = ~~Math.seededRandom(0, 2);
            }
        });

        generateCells(grid, options);

        // inverter.invert(data);

        // rooms.identify(0, data);
        // rooms.closeAll(data);
        // rooms.open(0, data);

        // addOutlineWalls();
        // addHeight();

        // list.print(grid.data);

    }
};

function generateCells(grid, options) {
    for (var i = 0; i < options.smoothness; i++) {

        var new_map = [];
        list.fill(new_map, grid.width * grid.width, 0);

        var x_low = -1;
        var x_high = -1;
        var y_low = -1;
        var y_high = -1;
        var neighbours = 0;
        var cur_tile_value = -1;
        var corner = false;
        var val = -1;

        // list.each(new_map, grid.width, function(tile, x, y, i) {
        new_map.each(grid.width, function(tile, x, y, i) {

            x_low = Math.max(0, x - 1);
            x_high = Math.min(grid.width - 1, x + 1);

            y_low = Math.max(0, y - 1);
            y_high = Math.min(grid.width - 1, y + 1);

            neighbours = 0;

            for (var a = x_low; a <= x_high; a++) {
                for (var b = y_low; b <= y_high; b++) {
                    if ((a === x) && (b === y)) {
                        continue;
                    }
                    neighbours += 1 - get(grid, a, b);
                }
            }

            cur_tile_value = get(grid, x, y);

            corner = (x === 0 && y === 0) ||
                     (x === grid.width-1 && y === 0) ||
                     (x === 0 && y === grid.height-1) ||
                     (x === grid.width-1 && y === grid.height-1);

            val = (corner ||
                  (cur_tile_value === 0 && neighbours >= 4) ||
                  (cur_tile_value === 1 && neighbours >= 5)) ? 0 : 1;

            list.set(new_map, x, y, grid.width, val);

        });

        new_map.forEach(function(value, i) {
            grid.data[i] = new_map[i];
        });
    }

    grid.data.forEach(function(value, i) {
        grid.data[i] = value === 0 ? options.value_a : options.value_b;
    });
}

function get(grid, x, y) {
    return list.get(grid.data, x, y, grid.width);
}

// function filter(data, data_types) {
//     data.forEach(function(data_value, i) {
//         data[i] = filterValue(data_value, data_types);
//     });
// }

// function filterValue(value, data_types) {
//     for (var i=0; i<data_types.length; i++) {
//         var dtype = data_types[i];
//         if (value >= dtype.lower && value < dtype.upper) {
//             return dtype.value;
//         }
//     }
// }

// TODO:
// addHeight and addOutlineWalls are actually transformers, and should
// be put in separate files.

// function addHeight() {
//     data.each(function(tile, x, y) {
//         if (tile === 0 &&
//             data.get(x, y - 1) === 1) {
//             data.set(x, y, 2);
//         }
//     });
// }

// function addOutlineWalls() {
//     data.each(function(tile, x, y) {
//         if (tile === 0) {
//             if (((x > 0) && (data.get(x - 1, y) === 1)) ||
//                 ((y > 0) && (data.get(x, y - 1) === 1)) ||
//                 ((x < data.width - 1) && (data.get(x + 1, y) === 1)) ||
//                 ((y < data.width - 1) && (data.get(x, y + 1) === 1))) {
//                     data.set(x, y, 2);
//                 }
//         }

//     });
// }

},{"./../utils/list.js":63}],43:[function(require,module,exports){

var endings = ['os', 'ia'];
var beginnings = ['Nax', 'Lesb', 'K', 'Icar', 'Tin', 'Skyr'];

module.exports.generate = function() {
    var b = rnd(beginnings);
    var e = rnd(endings);
    return b+e;
};

function rnd(list) {
    return list[Math.round(Math.random() * (list.length-1))];
}

},{}],44:[function(require,module,exports){
"use strict";

var list            = require('./../utils/list.js');
var type            = require('./../utils/type.js');
var grid            = require('./../data/grid.js');
var automata        = require('./cellular_automata.js');
var automata        = require('./cellular_automata.js');
var island_name     = require('./island_name.js');
// var remapper        = require('transforms/grid/remap');
var rooms           = require('./../transforms/grid/rooms.js');
var pier            = require('./../transforms/grid/pier.js');
var config          = require('./../config.js');
var cu              = require('./../config_utils.js');
var tilemapper      = require('./../tilemapper.js');

var world           = {};
var cfg             = null;
var map_cfg         = null;
var data_types      = null;

module.exports.generate = function(x, y, type) {
    if (exists(x, y)) {
        return;
    }

    cfg = config.get('world_segment');
    map_cfg = config.get('map');
    data_types = map_cfg.data_types;
    addToCache(x, y);

    var segment = world[x][y] = grid.create(cfg.width, cfg.height, 0);
    segment.seed = Math.round(Math.random() * 10000);
    // segment.seed = 5388;
    log(segment.seed);

    // info(data_types, type, x, y, segment.seed);

    // TODO: Define the generators for each type as a recipe, and store
    // each recipe in an object with type as index

    if (type === 0) {
        // TODO: Generate sea name
        segment.name = 'Fishing sea';
        generateFishingSea(segment);
    }

    if (type === 1) {
        segment.name = 'null';
        generateShallowSea(segment);
    }

    if (type === 2) {
        segment.name = island_name.generate();
        generateIsland(segment, {
            seed:       segment.seed,
            smoothness: cfg.smoothness,
            padding:    cfg.padding,
            value_a:    cu.getDataTypeValue('Shallow sea'),
            value_b:    cu.getDataTypeValue('Island')
        });
    }

    // list.print(segment.data);

    tilemapper.map(segment, data_types, map_cfg.tilemaps.segment);

    return this.get(x, y);
};

module.exports.get = function(x, y) {
    if (!exists(x, y)) {
        return null;
    }

    return world[x][y];
};

function generateIsland(segment, opts) {

    // TODO: Make automata a Stream
    // https://github.com/winterbe/streamjs
    // or use async
    // https://www.npmjs.com/package/async
    automata.generate(segment, opts);

    // Remap 0's to 1's and 1's to 2's.
    // Should be better integrated with config.
    // datatype.get('Island')
    // datatype.get('Shallow sea')
    // remapper.remap(segment.data, {
    //     0: 1,
    //     1: 2
    // });

    rooms.identify(cu.getDataTypeValue('Island'), segment);

    // Paint each room as sand
    Object.keys(rooms.rooms).forEach(function(index) {
        var room_tiles = rooms.rooms[index];
        if (room_tiles.length < 10) {
            room_tiles.forEach(function(tile_index) {
                segment.data[tile_index] = cu.getDataTypeValue('Sand');
            });
        }
    });

    // Find the biggest island
    var l = 0;
    var i = -1;
    Object.keys(rooms.rooms).forEach(function(index) {
        var r = rooms.rooms[index];
        if (r.length > l) {
            l = r.length;
            i = index;
        }
    });

    pier.place(segment, rooms.rooms[i]);

}

function generateFishingSea(segment) {
    // list.each(segment.data, segment.width, function(tile, x, y, i) {
    segment.data.each(segment.width, function(value, x, y, i) {
        if ((x < 5) ||
            (x > segment.width - 6) ||
            (y < 5) ||
            (y > segment.height - 6)) {
            segment.data[i] = cu.getDataTypeValue('Shallow sea');
        } else {
            segment.data[i] = cu.getDataTypeValue('Deep sea');
        }
    });
}

function generateShallowSea(segment) {
    // list.each(segment.data, segment.width, function(tile, x, y, i) {
    segment.data.each(segment.width, function(tile, x, y, i) {
        segment.data[i] = cu.getDataTypeValue('Shallow sea');
    });
}

function exists(x, y) {
    if (type(x).is_undefined) {
        console.log('Segment.exists : Missing x');
        return false;
    }

    if (!type(world[x]).is_undefined) {
        if (type(y).is_undefined) {
            return true;
        }
        if (!type(world[x][y]).is_undefined) {
            return true;
        }
    }
    return false;
}

function addToCache(x, y) {
    if (!exists(x)) {
        world[x] = {};
    }
    if (!exists(x, y)) {
        world[x][y] = {};
    }
}

function info(data_types, type, x, y, seed) {
    var n = '';
    data_types.forEach(function(dt) {
        if (dt.value === type) {
            n = dt.name;
        }
    });

    log('segment type:'+n+' ('+type+') x:'+x+' y:'+y+' seed:'+seed);
}

},{"./../config.js":29,"./../config_utils.js":30,"./../data/grid.js":34,"./../tilemapper.js":54,"./../transforms/grid/pier.js":55,"./../transforms/grid/rooms.js":56,"./../utils/list.js":63,"./../utils/type.js":64,"./cellular_automata.js":42,"./island_name.js":43}],45:[function(require,module,exports){
var config          = require('./../config.js');
var PerlinGenerator = require('proc-noise');
var grid            = require('./../data/grid.js');
var list            = require('./../utils/list.js');
var type            = require('./../utils/type.js');

var map = {};
var cfg = {};

module.exports.generate = function(data_types, seed) {
    cfg = config.get('world');

    var Perlin = new PerlinGenerator(seed);
    var noise = [];
    var scale = 1 / cfg.noise_scale;

    map = grid.create(cfg.width, cfg.height, 0);

    list.fill(noise, map.width * map.height, 0);
    noise.each(map.width, function(tile, x, y, i) {
        noise[i] = Perlin.noise(x * scale, y * scale);
    });

    filter(noise, map, data_types);

    list.print(map.data);
};

function filter(data, grid, config) {
    data.forEach(function(data_value, i) {
        grid.data[i] = filterValue(data_value, config);
    });
}

function filterValue(value, config) {
    for (var i=0; i<config.length; i++) {
        var cfg = config[i];
        if (type(cfg.lower).is_undefined &&
            type(cfg.upper).is_undefined) {
            continue;
        }
        if (value >= cfg.lower && value < cfg.upper) {
            return cfg.value;
        }
    }
}

Object.defineProperty(module.exports, 'map', {
    get: function() { return map; }
});

},{"./../config.js":29,"./../data/grid.js":34,"./../utils/list.js":63,"./../utils/type.js":64,"proc-noise":26}],46:[function(require,module,exports){
"use strict";

var config          = require('./../../config.js');
var update          = require('./update.js');

var triggers = {};
var player;
var system_type;
var system;
var game;

module.exports.init = function(g) {
    game = g;
    var system_id = config.get('game', 'physics_system');
    system_type = Phaser.Physics[system_id];
    game.physics.startSystem(system_type);
    system = game.physics[system_id.toLowerCase()];
    update.register(this);
}

// Public accessor for triggers
module.exports.triggers = {};

module.exports.enable = function(sprite) {
    game.physics.enable(sprite, system_type);
}

module.exports.collide = function(a, b) {
    system.collide(a, b);
}

// Terrible! Why must the physics system depend on player?
module.exports.setPlayer = function(p) {
    player = p;
}

module.exports.addTrigger = function(owner, name) {
    triggers[name] = {
        owner:      owner,
        active:     false
    };

    Object.defineProperty(module.exports.triggers, name, {
        get: function() { return triggers[name]; }
    });
}

module.exports.update = function() {
    var trigger;
    Object.keys(triggers).forEach(function(name) {
        trigger = triggers[name];
        if (Phaser.Rectangle.intersects(player.current.sprite.getBounds(),
                                        trigger.owner.bounds)) {
            if (!trigger.active) {
                trigger.owner.triggerEnter(player);
                player.triggerEnter(trigger.owner);
                trigger.active = true;
            }
            trigger.owner.triggerStay(player);
            player.triggerStay(trigger.owner);

        } else {
            if (trigger.active) {
                trigger.owner.triggerLeave(player);
                player.triggerLeave(trigger.owner);
                trigger.active = false;
            }
        }
    });
}

},{"./../../config.js":29,"./update.js":47}],47:[function(require,module,exports){
"use strict";

// Use this module to hook up an update function to Phaser's update loop

// TODO: Figure out a way to get rid of the init function so the module
// can initialize itself

var updates = [];
var inited = false;

module.exports = {
    init: function() {
        var game = require('./../../states/boot.js').game;
        game.world.children.push(this);
        inited = true;
    },

    register: function(entity) {
        if (!inited) {
            this.init();
        }

        updates.push(entity);
    },

    update: function() {
        for (var i=0, j=updates.length; i<j; i++) {
            updates[i].update();
        }
    },

    // When adding a non-Phaser object to Phaser's update loop, the object
    // needs these functions in order not to throw errors.
    preUpdate: function() {},
    postUpdate: function() {},
    updateTransform: function() {},
    _renderCanvas: function() {},
};

},{"./../../states/boot.js":49}],48:[function(require,module,exports){
"use strict";

module.exports = new Phaser.State();

var config          = require('./../config.js');
var cu              = require('./../config_utils.js');
var input           = require('./../controllers/input.js');
var level           = require('./../controllers/level.js');
var player          = require('./../entities/player.js');
var pier            = require('./../entities/pier.js');
var physics         = require('./../helpers/phaser/physics.js');
var segment         = require('./../generators/segment.js');
var list            = require('./../utils/list.js');
var ui              = require('./../ui/ui_manager.js');

var game;
var coord = {};
var layer_main;
var map_data;

module.exports.init = function(options) {
    map_data = segment.generate(0, 0, 2);
};

module.exports.create = function() {
    var game_config = config.get('game');

    game = this.game;
    game.stage.backgroundColor = game_config.background_color;

    physics.init(game);
    input.init(game);

    layer_main = level.createMap(game, {
        name: 'island',
        data: list.printString(map_data.tiles, map_data.width)
    });

    pier.create(level.map.tileWidth,
                level.map.tileHeight,
                map_data.meta.pier_pos);

    player.init(game, {
        layer:         layer_main,
        tile_width:    level.map.tileWidth,
        tile_height:   level.map.tileHeight,
        spawn_pos:     map_data.meta.boat_pos
    });

    ui.init(game);
};

module.exports.shutdown = function() {
    level.removeLayer(game, 'island');
};

module.exports.update = function() {
    // coord.x = layer_main.getTileX(input.pointer.worldX);
    // coord.y = layer_main.getTileY(input.pointer.worldY);
};

module.exports.render = function() {
    // game.debug.text(coord.x+' : '+coord.y, 16, 16, 'rgb(255,255,255)');
    // game.debug.body(player.current.sprite);
};

},{"./../config.js":29,"./../config_utils.js":30,"./../controllers/input.js":31,"./../controllers/level.js":32,"./../entities/pier.js":38,"./../entities/player.js":39,"./../generators/segment.js":44,"./../helpers/phaser/physics.js":46,"./../ui/ui_manager.js":59,"./../utils/list.js":63}],49:[function(require,module,exports){
"use strict";

var config = require('./../config.js');

module.exports = new Phaser.State();

module.exports.create = function() {
    var game_config = config.get('game');
    var game = this.game;
    var scale = game.scale;

    game.input.maxPointers = 1;
    game.antialias = false;
    Phaser.Canvas.setSmoothingEnabled(game.context, false);

    game.stage.scaleMode = Phaser.ScaleManager.NO_SCALE;
    scale.maxWidth = game_config.width;
    scale.maxHeight = game_config.height;
    scale.forceLandscape = true;
    scale.pageAlignHorizontally = true;
    scale.pageAlignVertically = true;
    scale.setScreenSize(true);

    // TODO: Doesn't work in Chrome. Get's reset
    // Apparently Chrome 41 has added pixel rendering
    game.context.imageSmoothingEnabled = false;
    game.context.mozImageSmoothingEnabled = false;
    game.context.oImageSmoothingEnabled = false;
    game.context.webkitImageSmoothingEnabled = false;
    game.context.msImageSmoothingEnabled = false;

    game.renderer.renderSession.roundPixels = true;

    game.state.start(config.get('game', 'boot_sequence').next());
};

},{"./../config.js":29}],50:[function(require,module,exports){
"use strict";

module.exports = new Phaser.State();

var config          = require('./../config.js');
var list            = require('./../utils/list.js');
var level           = require('./../controllers/level.js');
var segment         = require('./../generators/segment.js');

var game            = null;
var coordinate      = {x: -1, y: -1};
var key_map         = null;

module.exports.init = function(options) {
    if (typeof options === 'undefined') {
        console.log('Game state is missing options');
        return;
    }

    coordinate.x = options.x;
    coordinate.y = options.y;

    segment.generate(options.x, options.y, options.map_type);
};

module.exports.create = function() {
    var game_config = config.get('game');

    game = this.game;
    game.stage.backgroundColor = game_config.background_color;

    var seg = segment.get(coordinate.x, coordinate.y);
    level.createMap(game, {
        name: 'island',
        data: list.printString(seg.tiles, seg.width)
    });

    game.add.bitmapText(16, 16, 'Gamegirl', '[M] Return to worldmap', 8);
    game.add.bitmapText(16, 32, 'Gamegirl', seg.name, 8);

    key_map = game.input.keyboard.addKey(Phaser.Keyboard.M);
    key_map.onUp.add(returnToWorldmap, this);
};

module.exports.shutdown = function() {
    key_map.onUp.remove(returnToWorldmap);
    level.removeLayer(game, 'island');
};

function returnToWorldmap() {
    game.state.start('Worldmap');
}

},{"./../config.js":29,"./../controllers/level.js":32,"./../generators/segment.js":44,"./../utils/list.js":63}],51:[function(require,module,exports){
"use strict";

module.exports = new Phaser.State();

var world       = require('./../generators/world.js');
var tilemapper  = require('./../tilemapper.js');
var config      = require('./../config.js');

module.exports.create = function() {

    // TODO: Store the seed in a save game, e.g. localStorage.
    window.seed = Math.round(Math.random() * 10000);

    var map_cfg = config.get('map');
    world.generate(map_cfg.data_types, window.seed);

    tilemapper.map(world.map, map_cfg.data_types, map_cfg.tilemaps.worldmap);

    this.game.state.start(config.get('game', 'boot_sequence').next());

    // this.game.state.start('Game', true, false, {
    //     map_type:   2,
    //     x:          0,
    //     y:          0
    // });

};

},{"./../config.js":29,"./../generators/world.js":45,"./../tilemapper.js":54}],52:[function(require,module,exports){
"use strict";

var config = require('./../config.js');

module.exports = new Phaser.State();

module.exports.preload = function() {
    var assets = config.get('preload');
    Object.keys(assets).forEach(function(type) {
        Object.keys(assets[type]).forEach(function(id) {
            this.game.load[type].apply(this.game.load,
                                       [id].concat(assets[type][id]));
        }.bind(this));
    }.bind(this));
};

module.exports.update = function() {
    if (this.game.load.hasLoaded) {
        this.game.state.start(config.get('game', 'boot_sequence').next());
    }
};

},{"./../config.js":29}],53:[function(require,module,exports){
"use strict";

module.exports = new Phaser.State();

var config          = require('./../config.js');
var list            = require('./../utils/list.js');
var level           = require('./../controllers/level.js');
var world           = require('./../generators/world.js');
var unobtrusive     = require('./../ui/components/unobtrusive_label.js');

var marker      = {x:0, y:0};
var cur_tile    = {x:0, y:0};
var layer       = {};
var tilesize    = 32;
var pointer     = {};
var game        = null;

var pick_island_label = null;

module.exports.create = function() {
    var game_config = config.get('game');
    var mapname = 'worldmap';

    game = this.game;
    game.stage.backgroundColor = game_config.background_color;
    pointer = game.input.activePointer;

    layer = level.createMap(game, {
        // debug: true,
        tileset: 'worldmap-simple',
        name: 'worldmap',
        tile_size: 32,
        data: list.printString(world.map.tiles, world.map.width)
    });

    marker = game.add.sprite(0, 0, 'sprites-32');
    marker.frame = 3;

    game.add.bitmapText(16, 16, 'Gamegirl', 'Worldmap', 8);

    pick_island_label = unobtrusive.create({
        game:   game,
        sprite: 'label-pick-island'
    });

    game.input.onUp.add(click, this);
};

module.exports.shutdown = function() {
    game.input.onUp.remove(click, this);
    level.removeLayer(game, 'worldmap');
};

module.exports.update = function() {
    cur_tile.x = layer.getTileX(pointer.worldX);
    cur_tile.y = layer.getTileY(pointer.worldY);

    marker.x = cur_tile.x * tilesize;
    marker.y = cur_tile.y * tilesize;

    pick_island_label.update(pointer);
};

function click() {
    var map_type = list.get(world.map.data,
                            cur_tile.x,
                            cur_tile.y,
                            world.map.width);

    game.state.start('Game', true, false, {
        map_type:   map_type,
        x:          cur_tile.x,
        y:          cur_tile.y
    });
}

},{"./../config.js":29,"./../controllers/level.js":32,"./../generators/world.js":45,"./../ui/components/unobtrusive_label.js":58,"./../utils/list.js":63}],54:[function(require,module,exports){
var gridcreator     = require('./data/grid.js');
var list            = require('./utils/list.js');

module.exports.map = function(grid, data_types, tilemap) {
    // list.each(grid.data, grid.width, function(tile_value, x, y, i) {
    grid.data.each(grid.width, function(tile_value, x, y, i) {
        grid.tiles[i] = tilemap[tile_value];
    });
};

},{"./data/grid.js":34,"./utils/list.js":63}],55:[function(require,module,exports){
"use strict";

var config          = require('./../../config.js');
var cu              = require('./../../config_utils.js');

var type;
var data_types;

module.exports.place = function(segment, area) {
    var pier_positions = [];

    data_types = config.get('map').data_types;
    type = {
        shallow_sea:    cu.getDataTypeValue('Shallow sea'),
        island:         cu.getDataTypeValue('Island'),
        pier:           cu.getDataTypeValue('Pier')
    }

    segment.generatePathfindingData([type.shallow_sea]);

    // Could this be simplified?
    area.forEach(function(tile_index) {
        var above = segment.data[tile_index - segment.width];
        var below = segment.data[tile_index + segment.width];
        var left = segment.data[tile_index - 1];
        var at_right = segment.data[tile_index + 1];

        var neighbour_sea = (above === type.shallow_sea ? 1 : 0) +
                            (at_right === type.shallow_sea ? 1 : 0) +
                            (below === type.shallow_sea ? 1 : 0) +
                            (left === type.shallow_sea ? 1 : 0);

        if (neighbour_sea === 1) {

            var neighbour_island = (above === type.island ? 1 : 0) +
                                   (at_right === type.island ? 1 : 0) +
                                   (below === type.island ? 1 : 0) +
                                   (left === type.island ? 1 : 0);

            if (neighbour_island === 3) {

                var tl = segment.data[(tile_index - segment.width) - 1];
                var tr = segment.data[(tile_index - segment.width) + 1];
                var bl = segment.data[(tile_index + segment.width) - 1];
                var br = segment.data[(tile_index + segment.width) + 1];

                // Sea tiles diagonally neighbouring
                var ds = (tl === type.shallow_sea ? 1 : 0) +
                         (tr === type.shallow_sea ? 1 : 0) +
                         (bl === type.shallow_sea ? 1 : 0) +
                         (br === type.shallow_sea ? 1 : 0);

                if (ds === 2) {
                    var coord = getNeighbouringWaterTile(tile_index, segment);
                    if (coord) {
                        pier_positions.push(coord);
                    }
                }
            }
        }
    });

    if (pier_positions.length === 0) {
        console.log('no valid positions!');
        return;
    }

    var found = false;

    while (!found) {
        if (pier_positions.length === 0) {
            console.log('Could not find a suitable place for a pier');
            found = true;
        }

        var len = pier_positions.length > 1 ? pier_positions.length - 1 : 0;
        var index = Math.round(Math.random() * len);
        var pos = pier_positions.splice(index, 1)[0];

        var path = segment.findPath(pos.x, pos.y, 0, 0);
        if (path.length > 0) {
            var end = path[path.length - 1];
            if (end[0] === 0 && end[1] === 0) {
                var pier_pos = (pos.y * segment.width) + pos.x;
                segment.data[pier_pos] = type.pier;
                segment.meta.pier_pos = {x: pos.x, y: pos.y};
                segment.meta.boat_pos = getBoatPos(segment, pier_pos);
                found = true;
            }
        }
    }
}

function getBoatPos(segment, pier_pos) {
    var neighbours = [
        pier_pos - segment.width,
        pier_pos + 1,
        pier_pos + segment.width,
        pier_pos - 1
    ];
    var opposites = [
        pier_pos + segment.width,
        pier_pos - 1,
        pier_pos - segment.width,
        pier_pos + 1
    ];

    for (var i=0; i<neighbours.length; i++) {
        var n = neighbours[i];
        if (segment.data[n] === type.island) {
            return coordForIndex(opposites[i], segment.width);
        }
    }

    return null;
}

function getNeighbouringWaterTile(tile_index, segment) {
    var neighbours = [
        tile_index - segment.width,
        tile_index + 1,
        tile_index + segment.width,
        tile_index - 1
    ];

    for (var i=0; i<neighbours.length; i++) {
        var n = neighbours[i];
        if (segment.data[n] === type.shallow_sea) {
            return coordForIndex(n, segment.width);
        }
    }

    return null;
}

function coordForIndex(index, w) {
    return {
        y: Math.floor(index / w),
        x: index - (w * Math.floor(index / w))
    };
}

},{"./../../config.js":29,"./../../config_utils.js":30}],56:[function(require,module,exports){
var list = require('./../../utils/list.js');

var rooms = {};

module.exports = {
    identify: function(index, grid) {

        var data = [];
        var rooms_tmp = [];

        grid.data.each(grid.width, function(tile, x, y, i) {
            data.push(tile);
        });

        data.forEach(function(tile, i) {
            if (tile === index && !inCache(rooms_tmp, tile)) {
                rooms_tmp.push({});
                crawl(data, grid.width, i, rooms_tmp[rooms_tmp.length-1]);
            }
        });

        rooms_tmp.forEach(function(room, i) {
            var indexes = Object.keys(room);
            rooms[i] = [];
            var r = rooms[i];

            indexes.forEach(function(index) {
                r.push(parseInt(index));
            });
        });
    },

    closeAll: function(grid) {
        Object.keys(rooms).forEach(function(room_num) {
            close(room_num, grid);
        });
    },

    open: function(room_num, grid) {
        if (!rooms[room_num]) {
            return;
        }

        var room = rooms[room_num];
        room.forEach(function(tile) {
            grid._[tile] = 0;
        });
    }
};

function close(room_num, grid) {
    var room = rooms[room_num];
    room.forEach(function(tile) {
        grid._[tile] = 1;
    });
}

function inCache(cache, index) {
    if (cache.length === 0) {
        return false;
    }

    for (var i=0; i<cache.length; i+=1) {
        var group = cache[i];
        return group[index] ? true : false;
    }
}

function crawl(data, width, i, container) {
    var index = data[i];
    var right = i+1;
    var left = i-1;
    var below = i+width;
    var above = i-width;

    data[i] = 3;
    container[i] = true;

    if (data[right] === index) {
        crawl(data, width, right, container);
    }
    if (data[left] === index) {
        crawl(data, width, left, container);
    }
    if (data[below] === index) {
        crawl(data, width, below, container);
    }
    if (data[above] === index) {
        crawl(data, width, above, container);
    }
}

Object.defineProperty(module.exports, 'rooms', {
    get: function() { return rooms; }
});

},{"./../../utils/list.js":63}],57:[function(require,module,exports){
"use strict";

// function Label(_game, _x, _y, _width, _height) {
//     this.game = _game;
//     this.x = _x;
//     this.y = _y;
//     this.width = _width;
//     this.height = _height;
//     // this.caption = null;

//     this.label = this.game.add.bitmapText(this.x, this.y,
//                                          'Gamegirl', this.caption, 16);
// }

// Label.prototype = {
//     show: function(text) {
//         this.label.text = text;
//         this.label.visible = true;
//     },

//     render: function() {
//         if (!this.label.visible) {
//             return;
//         }
//         this.label.visible = false;
//     }

// };


module.exports.create = function(game, x, y, width, height) {
    // TODO: replace font and size with settings from config
    var label = game.add.bitmapText(x, y, 'Gamegirl', 'N/A', 16);
    // label.visible = false;
    return label;
}

},{}],58:[function(require,module,exports){
"use strict";

// TODO:
// - set anchor
// - add support for bitmap text
// - use 9grid slicing for the background. Blit everything to a bitmapdata

function UnobtrusiveLabel(opts) {
    this.opts = opts || {
        game:   null,
        sprite: 'N/A'
    };

    if (opts.game === null) {
        console.log('Unobtrusive label could not be created. '+
                    'Pass a reference to game.');
        return;
    }

    this.label = this.opts.game.add.image(0, 0, this.opts.sprite);
    this.bottom = this.opts.game.world.height - (this.label.height * 2);
    this.top = this.label.height;

    this.label.x = this.opts.game.world.centerX - (this.label.width / 2);
    this.label.y = this.bottom;

    this.labelAtBottom = true;

    // this.tweenBottomOut = this.opts.game.add.tween(this.label);
    // this.tweenBottomIn = this.opts.game.add.tween(this.label);
    // this.tweenTopIn = this.opts.game.add.tween(this.label);
    // this.tweenTopOut = this.opts.game.add.tween(this.label);
}

UnobtrusiveLabel.prototype.update = function(pointer) {
    if (pointer.worldY > this.bottom && this.labelAtBottom) {
        this.labelAtBottom = false;
        this.tweenBottomOut = this.opts.game.add.tween(this.label).to({ y: this.opts.game.world.height }, 200, Phaser.Easing.Quadratic.Out, true);
        this.tweenBottomOut.onComplete.addOnce(this.fromAbove, this);
    }

    if (pointer.worldY < (this.top * 2) && !this.labelAtBottom) {
        this.labelAtBottom = true;
        this.tweenTopOut = this.opts.game.add.tween(this.label).to({ y: -this.label.height }, 200, Phaser.Easing.Quadratic.Out, true);
        this.tweenTopOut.onComplete.addOnce(this.fromBelow, this);
    }
};

UnobtrusiveLabel.prototype.fromAbove = function() {
    this.tweenBottomOut.onComplete.removeAll();
    this.label.y = -this.label.height;
    this.tweenTopIn = this.opts.game.add.tween(this.label).to({ y: this.top }, 100, Phaser.Easing.Quadratic.In, true);
    this.tweenTopIn.onComplete.addOnce(this.topInDone, this);
};

UnobtrusiveLabel.prototype.fromBelow = function() {
    this.tweenTopOut.onComplete.removeAll();
    this.label.y = this.opts.game.world.height;
    this.tweenBottomIn = this.opts.game.add.tween(this.label).to({ y: this.bottom }, 100, Phaser.Easing.Quadratic.In, true);
    this.tweenBottomIn.onComplete.addOnce(this.bottomInDone, this);
};

UnobtrusiveLabel.prototype.topInDone = function() {
    this.tweenTopIn.onComplete.removeAll();
};

UnobtrusiveLabel.prototype.bottomInDone = function() {
    this.tweenBottomIn.onComplete.removeAll();
};

module.exports.create = function(opts) {
    return new UnobtrusiveLabel(opts);
}

},{}],59:[function(require,module,exports){
"use strict";

// module.exports = new Phaser.Group();

// TODO: UI manager should have a very high z index in order to be rendered
// on top of everything else. The manager must therefore be an object
// that gets a z index (a sprite?), and the state needs to run sort() on world.

// UI manager should manage ui panels. A panel is a self contained set of
// components that is attached to a game state. It has properties and functions
// for transitioning in and out, hooking up to the update loop and other events
// by itself. Panels should transition in an out when state changes.

var label           = require('./components/label.js');
var input           = require('./../controllers/input.js');

var action_label;

module.exports.init = function(game) {
    // var group = game.add.group();
    // group.update = this.update;

    // var image = game.cache.getImage('label');
    // log(image);

    // action_label = nine_slice_scale.create(game, 'label', {
    //     top: 0, bottom: 22, left: 28, right: 28
    // });

    action_label = label.create(game, 16, 16);
}

// module.exports.update = function() {
// };

// Replace this with an event system. The events will need to be picked up
// by the various panels and components
module.exports.dispatch = function(name, payload) {
    if (typeof payload === 'undefined') {
        action_label.visible = false;
        return;
    }

    action_label.visible = true;

    if (name === 'action_label') {
        action_label.text = payload + ' [' + input.keys('action') + ']';
    }
};

// Object.defineProperty(module.exports, 'action_label', {
//     get: function() { return action_label; }
// });

},{"./../controllers/input.js":31,"./components/label.js":57}],60:[function(require,module,exports){
"use strict";

var config  = require('./../config.js');
var type_of = require('./type.js');

var tools_node = null;
var game_node = null;

function append_to_head(element) {
    document.getElementsByTagName('head')[0].appendChild(element);
};

function create_script(path) {
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.async = true;
    script.src = path;
    return script;
};

function create_node(id, parent_id) {
    var parent = document.body.nextSibling;
    if (!type_of(parent_id).is_undefined) {
        parent = document.getElementById(parent_id);
    }
    var div = document.createElement('div');
    div.setAttribute('id', id);
    document.body.insertBefore(div, parent);
    return div;
};

module.exports.add_game_node = function() {
    if (document) {
        game_node = create_node(config.get('game').dom_element_id);
        return game_node;
    }
    return null;
};

module.exports.inject_script = function(path, callback) {
    var script = create_script(config.get('game').host + path);
    script.onload = function() {
        if (!type_of(callback).is_undefined) {
            callback();
        }
    }
    append_to_head(script);
};

module.exports.inject_css = function(path, callback) {
    var link = document.createElement('link');
    link.setAttribute('rel', 'stylesheet');
    link.setAttribute('type', 'text/css')
    link.setAttribute('href', config.get('game').host + path);
    append_to_head(link);
    if (!type_of(callback).is_undefined) {
        callback();
    }
};

Object.defineProperty(module.exports, 'game_node', {
    get: function() { return game_node; }
});

},{"./../config.js":29,"./type.js":64}],61:[function(require,module,exports){
"use strict";

var slice = Array.prototype.slice;
var nativeForEach = Array.prototype.forEach;

var each = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
        for (var i = 0, l = obj.length; i < l; i++) {
            if (iterator.call(context, obj[i], i, obj) === breaker) return;
        }
    } else {
        for (var key in obj) {
            if (has(obj, key)) {
                if (iterator.call(context, obj[key], key, obj) === breaker) return;
            }
        }
    }
};

var has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
};

module.exports = function(obj) {
    each(slice.call(arguments, 1), function(source) {
        if (source) {
            for (var prop in source) {
                obj[prop] = source[prop];
            }
        }
    });
    return obj;
};

},{}],62:[function(require,module,exports){
Math.seededRandom = function(min, max) {
    min = min || 0;
    max = max || 1;

    Math.seed = (Math.seed * 9301 + 49297) % 233280;
    return min + (Math.seed / 233280) * (max - min);
}

Array.prototype.each = function(width, cb) {
    var y = 0, i = 0;
    for (i=0; i<this.length; i++) {
        y += i>0 && i%width===0 ? 1 : 0;
        cb(this[i], i%width, y, i);
    }
};

Array.prototype.next = function() {
    if (typeof this.__counter === 'undefined') {
        this.__counter = -1;
    }

    this.__counter++;

    if (this.__counter < this.length) {
        return this[this.__counter];
    }

    return null;
}

Array.prototype.equals = function (array) {
    // if the other array is a falsy value, return
    if (!array)
        return false;

    // compare lengths - can save a lot of time
    if (this.length != array.length)
        return false;

    for (var i = 0, l=this.length; i < l; i++) {
        // Check if we have nested arrays
        if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!this[i].equals(array[i]))
                return false;
        }
        else if (this[i] != array[i]) {
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;
        }
    }
    return true;
}

Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
}

},{}],63:[function(require,module,exports){
module.exports.get = function(arr, x, y, width) {
    return arr[(width * y) + x];
};

module.exports.set = function(arr, x, y, width, value) {
    arr[(width * y) + x] = value;
};

module.exports.fill = function(arr, length, value) {
    arr = arr || [];
    value = value || 0;

    for (var i=0; i<length; i+=1) {
        arr.push(value);
    }

    return module.exports;
};

module.exports.print = function(list, width) {
    var str = this.printString(list, width);
    console.log(str);
}

module.exports.printString = function(list, width) {
    if (!(list instanceof Array)) {
        console.log('list.print() needs an array');
        return;
    }

    if (typeof width === 'undefined') {
        var width = Math.sqrt(list.length);
        if (width % 1 !== 0) {
            console.log('list.print() cannot find the width for the current list');
            return;
        }
    }

    var str = '';

    // this.each(list, width, function(tile, x, y, i) {
    list.each(width, function(tile, x, y, i) {
        str += i % width !== 0 ? ',' : '\n';
        str += tile;
    });

    return str;
}

},{}],64:[function(require,module,exports){
"use strict";

var type = '';

module.exports = function(element) {
    type = Object.prototype.toString.call(element);
    return module.exports;
};

Object.defineProperty(module.exports, 'is_object', {
    get: function() { return type === '[object Object]'; }
});
Object.defineProperty(module.exports, 'is_array', {
    get: function() { return type === '[object Array]'; }
});
Object.defineProperty(module.exports, 'is_string', {
    get: function() { return type === '[object String]'; }
});
Object.defineProperty(module.exports, 'is_date', {
    get: function() { return type === '[object Date]'; }
});
Object.defineProperty(module.exports, 'is_number', {
    get: function() { return type === '[object Number]'; }
});
Object.defineProperty(module.exports, 'is_num', {
    get: function() { return type === '[object Number]'; }
});
Object.defineProperty(module.exports, 'is_function', {
    get: function() { return type === '[object Function]'; }
});
Object.defineProperty(module.exports, 'is_fn', {
    get: function() { return type === '[object Function]'; }
});
Object.defineProperty(module.exports, 'is_regexp', {
    get: function() { return type === '[object RegExp]'; }
});
Object.defineProperty(module.exports, 'is_boolean', {
    get: function() { return type === '[object Boolean]'; }
});
Object.defineProperty(module.exports, 'is_bool', {
    get: function() { return type === '[object Boolean]'; }
});
Object.defineProperty(module.exports, 'is_null', {
    get: function() { return type === '[object Null]'; }
});
Object.defineProperty(module.exports, 'is_undefined', {
    get: function() { return type === '[object Undefined]'; }
});
Object.defineProperty(module.exports, 'to_string', {
    get: function() { return type; }
});

},{}]},{},[1]);
